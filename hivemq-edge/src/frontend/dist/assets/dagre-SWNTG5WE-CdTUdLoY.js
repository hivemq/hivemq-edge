import{_ as v,ae as j,af as F,ag as Y,ah as H,l as r,c as V,ai as $,aj as U,a0 as q,a5 as z,a1 as P,$ as K,ak as Q,al as W,am as Z}from"./PropertyPanelController-B_GTknPx.js";import{G as B}from"./graph-fDbTnqOE.js";import{l as I}from"./layout-MfhNWExk.js";import{i as D}from"./_baseUniq-UwA5AnXX.js";import{c as L}from"./clone-DWpQoFSB.js";import{m as A}from"./_basePickBy-BpWhf_0p.js";import"./index-cMih3SEP.js";import"./index-iD7yky8Q.js";import"./types-CNm55BG_.js";import"./usePolicyGuards-DliXcvYq.js";import"./useDataHubDraftStore-BdIk6zJn.js";import"./index-UJo6opCj.js";import"./vanilla-Dd4Maacd.js";import"./middleware-DWkoLS6u.js";import"./index-Dis5-5gm.js";import"./index-BXWYaCHO.js";import"./without-BTTCd72_.js";import"./index-BTlOwmq4.js";import"./ArrayFieldTemplate-BvbIrrVp.js";import"./pick-DicWcAKr.js";import"./chunk-TRO7245M-Czmm3RtS.js";import"./chunk-JARCRF6W-CHhnzfpl.js";import"./chunk-ZPFGWTBB-27OtcFRz.js";import"./chunk-W7WUSNWJ-DJm2I2MC.js";import"./index-C23MLgnh.js";import"./chunk-RDF2AYID-BFNDpMsD.js";import"./creatable-select-CDfhMLkq.js";import"./use-chakra-select-props-D5NVA-bJ.js";import"./chunk-KC77MHL3-CpO6TSLY.js";import"./chunk-HB6KBUMZ-BnKuEGjs.js";import"./chunk-OCNORRQU-qVjYAyQ7.js";import"./index-DDmdO6wr.js";import"./select-Cl6Duh2E.js";import"./config.utils-FEQhkVx6.js";import"./toast-utils-BddXXXrS.js";import"./PaginatedTable-CpimMJK6.js";import"./datetime-B2_BsC7v.js";import"./chunk-KO6Q73AP-Bk5HKb-M.js";import"./chunk-VTV6N5LE-DWhDJEfB.js";import"./chunk-RPO2WXNL-BTibYaQa.js";import"./chunk-EL2VKIZQ-C-XtNqj-.js";import"./useListProtocolAdapters-B80RXV7q.js";import"./ArrayFieldItemTemplate-CQ7KDBCe.js";import"./color-Cs2FUV59.js";import"./useGetAllSchemas-BHgSFldN.js";import"./utils-Da84xa3e.js";import"./SchemaNode.utils-CqHD45U7.js";import"./index-C46KiF-i.js";import"./useGetAllDataPolicies-C_g1xUlx.js";import"./chunk-FHHZMTWR-BZ2wKB7t.js";import"./useGetAllBehaviorPolicies-C8fnxDpN.js";import"./step-BUvoxw0L.js";import"./bump-DxSIDwFB.js";/* empty css              */(function(){try{var e=typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},t=new e.Error().stack;t&&(e._sentryDebugIds=e._sentryDebugIds||{},e._sentryDebugIds[t]="90fc8e2a-0815-4f2b-b181-9fae91f423ee",e._sentryDebugIdIdentifier="sentry-dbid-90fc8e2a-0815-4f2b-b181-9fae91f423ee")}catch{}})();function X(e){var t={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:ee(e),edges:ne(e)};return D(e.graph())||(t.value=L(e.graph())),t}function ee(e){return A(e.nodes(),function(t){var n=e.node(t),o=e.parent(t),c={v:t};return D(n)||(c.value=n),D(o)||(c.parent=o),c})}function ne(e){return A(e.edges(),function(t){var n=e.edge(t),o={v:t.v,w:t.w};return D(t.name)||(o.name=t.name),D(n)||(o.value=n),o})}var f=new Map,N=new Map,J=new Map,te=v(()=>{N.clear(),J.clear(),f.clear()},"clear"),O=v((e,t)=>{const n=N.get(t)||[];return r.trace("In isDescendant",t," ",e," = ",n.includes(e)),n.includes(e)},"isDescendant"),ie=v((e,t)=>{const n=N.get(t)||[];return r.info("Descendants of ",t," is ",n),r.info("Edge is ",e),e.v===t||e.w===t?!1:n?n.includes(e.v)||O(e.v,t)||O(e.w,t)||n.includes(e.w):(r.debug("Tilt, ",t,",not in descendants"),!1)},"edgeInCluster"),G=v((e,t,n,o)=>{r.warn("Copying children of ",e,"root",o,"data",t.node(e),o);const c=t.children(e)||[];e!==o&&c.push(e),r.warn("Copying (nodes) clusterId",e,"nodes",c),c.forEach(a=>{if(t.children(a).length>0)G(a,t,n,o);else{const s=t.node(a);r.info("cp ",a," to ",o," with parent ",e),n.setNode(a,s),o!==t.parent(a)&&(r.warn("Setting parent",a,t.parent(a)),n.setParent(a,t.parent(a))),e!==o&&a!==e?(r.debug("Setting parent",a,e),n.setParent(a,e)):(r.info("In copy ",e,"root",o,"data",t.node(e),o),r.debug("Not Setting parent for node=",a,"cluster!==rootId",e!==o,"node!==clusterId",a!==e));const u=t.edges(a);r.debug("Copying Edges",u),u.forEach(l=>{r.info("Edge",l);const h=t.edge(l.v,l.w,l.name);r.info("Edge data",h,o);try{ie(l,o)?(r.info("Copying as ",l.v,l.w,h,l.name),n.setEdge(l.v,l.w,h,l.name),r.info("newGraph edges ",n.edges(),n.edge(n.edges()[0]))):r.info("Skipping copy of edge ",l.v,"-->",l.w," rootId: ",o," clusterId:",e)}catch(C){r.error(C)}})}r.debug("Removing node",a),t.removeNode(a)})},"copy"),R=v((e,t)=>{const n=t.children(e);let o=[...n];for(const c of n)J.set(c,e),o=[...o,...R(c,t)];return o},"extractDescendants"),re=v((e,t,n)=>{const o=e.edges().filter(l=>l.v===t||l.w===t),c=e.edges().filter(l=>l.v===n||l.w===n),a=o.map(l=>({v:l.v===t?n:l.v,w:l.w===t?t:l.w})),s=c.map(l=>({v:l.v,w:l.w}));return a.filter(l=>s.some(h=>l.v===h.v&&l.w===h.w))},"findCommonEdges"),S=v((e,t,n)=>{const o=t.children(e);if(r.trace("Searching children of id ",e,o),o.length<1)return e;let c;for(const a of o){const s=S(a,t,n),u=re(t,n,s);if(s)if(u.length>0)c=s;else return s}return c},"findNonClusterChild"),k=v(e=>!f.has(e)||!f.get(e).externalConnections?e:f.has(e)?f.get(e).id:e,"getAnchorId"),se=v((e,t)=>{if(!e||t>10){r.debug("Opting out, no graph ");return}else r.debug("Opting in, graph ");e.nodes().forEach(function(n){e.children(n).length>0&&(r.warn("Cluster identified",n," Replacement id in edges: ",S(n,e,n)),N.set(n,R(n,e)),f.set(n,{id:S(n,e,n),clusterData:e.node(n)}))}),e.nodes().forEach(function(n){const o=e.children(n),c=e.edges();o.length>0?(r.debug("Cluster identified",n,N),c.forEach(a=>{const s=O(a.v,n),u=O(a.w,n);s^u&&(r.warn("Edge: ",a," leaves cluster ",n),r.warn("Descendants of XXX ",n,": ",N.get(n)),f.get(n).externalConnections=!0)})):r.debug("Not a cluster ",n,N)});for(let n of f.keys()){const o=f.get(n).id,c=e.parent(o);c!==n&&f.has(c)&&!f.get(c).externalConnections&&(f.get(n).id=c)}e.edges().forEach(function(n){const o=e.edge(n);r.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(n)),r.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(e.edge(n)));let c=n.v,a=n.w;if(r.warn("Fix XXX",f,"ids:",n.v,n.w,"Translating: ",f.get(n.v)," --- ",f.get(n.w)),f.get(n.v)||f.get(n.w)){if(r.warn("Fixing and trying - removing XXX",n.v,n.w,n.name),c=k(n.v),a=k(n.w),e.removeEdge(n.v,n.w,n.name),c!==n.v){const s=e.parent(c);f.get(s).externalConnections=!0,o.fromCluster=n.v}if(a!==n.w){const s=e.parent(a);f.get(s).externalConnections=!0,o.toCluster=n.w}r.warn("Fix Replacing with XXX",c,a,n.name),e.setEdge(c,a,o,n.name)}}),r.warn("Adjusted Graph",X(e)),T(e,0),r.trace(f)},"adjustClustersAndEdges"),T=v((e,t)=>{var c,a;if(r.warn("extractor - ",t,X(e),e.children("D")),t>10){r.error("Bailing out");return}let n=e.nodes(),o=!1;for(const s of n){const u=e.children(s);o=o||u.length>0}if(!o){r.debug("Done, no node has children",e.nodes());return}r.debug("Nodes = ",n,t);for(const s of n)if(r.debug("Extracting node",s,f,f.has(s)&&!f.get(s).externalConnections,!e.parent(s),e.node(s),e.children("D")," Depth ",t),!f.has(s))r.debug("Not a cluster",s,t);else if(!f.get(s).externalConnections&&e.children(s)&&e.children(s).length>0){r.warn("Cluster without external connections, without a parent and with children",s,t);let l=e.graph().rankdir==="TB"?"LR":"TB";(a=(c=f.get(s))==null?void 0:c.clusterData)!=null&&a.dir&&(l=f.get(s).clusterData.dir,r.warn("Fixing dir",f.get(s).clusterData.dir,l));const h=new B({multigraph:!0,compound:!0}).setGraph({rankdir:l,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});r.warn("Old graph before copy",X(e)),G(s,e,h,s),e.setNode(s,{clusterNode:!0,id:s,clusterData:f.get(s).clusterData,label:f.get(s).label,graph:h}),r.warn("New graph after copy node: (",s,")",X(h)),r.debug("Old graph after copy",X(e))}else r.warn("Cluster ** ",s," **not meeting the criteria !externalConnections:",!f.get(s).externalConnections," no parent: ",!e.parent(s)," children ",e.children(s)&&e.children(s).length>0,e.children("D"),t),r.debug(f);n=e.nodes(),r.warn("New list of nodes",n);for(const s of n){const u=e.node(s);r.warn(" Now next level",s,u),u!=null&&u.clusterNode&&T(u.graph,t+1)}},"extractor"),_=v((e,t)=>{if(t.length===0)return[];let n=Object.assign([],t);return t.forEach(o=>{const c=e.children(o),a=_(e,c);n=[...n,...a]}),n},"sorter"),oe=v(e=>_(e,e.children()),"sortNodesByHierarchy"),M=v(async(e,t,n,o,c,a)=>{r.warn("Graph in recursive render:XAX",X(t),c);const s=t.graph().rankdir;r.trace("Dir in recursive render - dir:",s);const u=e.insert("g").attr("class","root");t.nodes()?r.info("Recursive render XXX",t.nodes()):r.info("No nodes found for",t),t.edges().length>0&&r.info("Recursive edges",t.edge(t.edges()[0]));const l=u.insert("g").attr("class","clusters"),h=u.insert("g").attr("class","edgePaths"),C=u.insert("g").attr("class","edgeLabels"),m=u.insert("g").attr("class","nodes");await Promise.all(t.nodes().map(async function(d){const i=t.node(d);if(c!==void 0){const w=JSON.parse(JSON.stringify(c.clusterData));r.trace(`Setting data for parent cluster XXX
 Node.id = `,d,`
 data=`,w.height,`
Parent cluster`,c.height),t.setNode(c.id,w),t.parent(d)||(r.trace("Setting parent",d,c.id),t.setParent(d,c.id,w))}if(r.info("(Insert) Node XXX"+d+": "+JSON.stringify(t.node(d))),i!=null&&i.clusterNode){r.info("Cluster identified XBX",d,i.width,t.node(d));const{ranksep:w,nodesep:p}=t.graph();i.graph.setGraph({...i.graph.graph(),ranksep:w+25,nodesep:p});const E=await M(m,i.graph,n,o,t.node(d),a),x=E.elem;$(i,x),i.diff=E.diff||0,r.info("New compound node after recursive render XAX",d,"width",i.width,"height",i.height),U(x,i)}else t.children(d).length>0?(r.trace("Cluster - the non recursive path XBX",d,i.id,i,i.width,"Graph:",t),r.trace(S(i.id,t)),f.set(i.id,{id:S(i.id,t),node:i})):(r.trace("Node - the non recursive path XAX",d,m,t.node(d),s),await q(m,t.node(d),{config:a,dir:s}))})),await v(async()=>{const d=t.edges().map(async function(i){const w=t.edge(i.v,i.w,i.name);r.info("Edge "+i.v+" -> "+i.w+": "+JSON.stringify(i)),r.info("Edge "+i.v+" -> "+i.w+": ",i," ",JSON.stringify(t.edge(i))),r.info("Fix",f,"ids:",i.v,i.w,"Translating: ",f.get(i.v),f.get(i.w)),await Z(C,w)});await Promise.all(d)},"processEdges")(),r.info("Graph before layout:",JSON.stringify(X(t))),r.info("############################################# XXX"),r.info("###                Layout                 ### XXX"),r.info("############################################# XXX"),I(t),r.info("Graph after layout:",JSON.stringify(X(t)));let b=0,{subGraphTitleTotalMargin:y}=z(a);return await Promise.all(oe(t).map(async function(d){var w;const i=t.node(d);if(r.info("Position XBX => "+d+": ("+i.x,","+i.y,") width: ",i.width," height: ",i.height),i!=null&&i.clusterNode)i.y+=y,r.info("A tainted cluster node XBX1",d,i.id,i.width,i.height,i.x,i.y,t.parent(d)),f.get(i.id).node=i,P(i);else if(t.children(d).length>0){r.info("A pure cluster node XBX1",d,i.id,i.x,i.y,i.width,i.height,t.parent(d)),i.height+=y,t.node(i.parentId);const p=(i==null?void 0:i.padding)/2||0,E=((w=i==null?void 0:i.labelBBox)==null?void 0:w.height)||0,x=E-p||0;r.debug("OffsetY",x,"labelHeight",E,"halfPadding",p),await K(l,i),f.get(i.id).node=i}else{const p=t.node(i.parentId);i.y+=y/2,r.info("A regular node XBX1 - using the padding",i.id,"parent",i.parentId,i.width,i.height,i.x,i.y,"offsetY",i.offsetY,"parent",p,p==null?void 0:p.offsetY,i),P(i)}})),t.edges().forEach(function(d){const i=t.edge(d);r.info("Edge "+d.v+" -> "+d.w+": "+JSON.stringify(i),i),i.points.forEach(x=>x.y+=y/2);const w=t.node(d.v);var p=t.node(d.w);const E=Q(h,i,f,n,w,p,o);W(i,E)}),t.nodes().forEach(function(d){const i=t.node(d);r.info(d,i.type,i.diff),i.isGroup&&(b=i.diff)}),r.warn("Returning from recursive render XAX",u,b),{elem:u,diff:b}},"recursiveRender"),cn=v(async(e,t)=>{var a,s,u,l,h,C;const n=new B({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:((a=e.config)==null?void 0:a.nodeSpacing)||((u=(s=e.config)==null?void 0:s.flowchart)==null?void 0:u.nodeSpacing)||e.nodeSpacing,ranksep:((l=e.config)==null?void 0:l.rankSpacing)||((C=(h=e.config)==null?void 0:h.flowchart)==null?void 0:C.rankSpacing)||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),o=t.select("g");j(o,e.markers,e.type,e.diagramId),F(),Y(),H(),te(),e.nodes.forEach(m=>{n.setNode(m.id,{...m}),m.parentId&&n.setParent(m.id,m.parentId)}),r.debug("Edges:",e.edges),e.edges.forEach(m=>{if(m.start===m.end){const g=m.start,b=g+"---"+g+"---1",y=g+"---"+g+"---2",d=n.node(g);n.setNode(b,{domId:b,id:b,parentId:d.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),n.setParent(b,d.parentId),n.setNode(y,{domId:y,id:y,parentId:d.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),n.setParent(y,d.parentId);const i=structuredClone(m),w=structuredClone(m),p=structuredClone(m);i.label="",i.arrowTypeEnd="none",i.id=g+"-cyclic-special-1",w.arrowTypeEnd="none",w.id=g+"-cyclic-special-mid",p.label="",d.isGroup&&(i.fromCluster=g,p.toCluster=g),p.id=g+"-cyclic-special-2",n.setEdge(g,b,i,g+"-cyclic-special-0"),n.setEdge(b,y,w,g+"-cyclic-special-1"),n.setEdge(y,g,p,g+"-cyc<lic-special-2")}else n.setEdge(m.start,m.end,{...m},m.id)}),r.warn("Graph at first:",JSON.stringify(X(n))),se(n),r.warn("Graph after XAX:",JSON.stringify(X(n)));const c=V();await M(o,n,e.type,e.diagramId,void 0,c)},"render");export{cn as render};
//# sourceMappingURL=dagre-SWNTG5WE-CdTUdLoY.js.map
