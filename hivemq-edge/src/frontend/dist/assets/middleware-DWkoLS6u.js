(function(){try{var a=typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},u=new a.Error().stack;u&&(a._sentryDebugIds=a._sentryDebugIds||{},a._sentryDebugIds[u]="f03b55cc-18cf-488d-b4e9-c958449c9ec2",a._sentryDebugIdIdentifier="sentry-dbid-f03b55cc-18cf-488d-b4e9-c958449c9ec2")}catch{}})();const _={};function b(a,u){let s;try{s=a()}catch{return}return{getItem:i=>{var e;const m=h=>h===null?null:JSON.parse(h,void 0),f=(e=s.getItem(i))!=null?e:null;return f instanceof Promise?f.then(m):m(f)},setItem:(i,e)=>s.setItem(i,JSON.stringify(e,void 0)),removeItem:i=>s.removeItem(i)}}const I=a=>u=>{try{const s=a(u);return s instanceof Promise?s:{then(o){return I(o)(s)},catch(o){return this}}}catch(s){return{then(o){return this},catch(o){return I(o)(s)}}}},w=(a,u)=>(s,o,i)=>{let e={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:n=>n,version:0,merge:(n,l)=>({...l,...n}),...u},m=!1;const f=new Set,h=new Set;let d;try{d=e.getStorage()}catch{}if(!d)return a((...n)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),s(...n)},o,i);const p=I(e.serialize),S=()=>{const n=e.partialize({...o()});let l;const t=p({state:n,version:e.version}).then(c=>d.setItem(e.name,c)).catch(c=>{l=c});if(l)throw l;return t},v=i.setState;i.setState=(n,l)=>{v(n,l),S()};const g=a((...n)=>{s(...n),S()},o,i);let y;const r=()=>{var n;if(!d)return;m=!1,f.forEach(t=>t(o()));const l=((n=e.onRehydrateStorage)==null?void 0:n.call(e,o()))||void 0;return I(d.getItem.bind(d))(e.name).then(t=>{if(t)return e.deserialize(t)}).then(t=>{if(t)if(typeof t.version=="number"&&t.version!==e.version){if(e.migrate)return e.migrate(t.state,t.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return t.state}).then(t=>{var c;return y=e.merge(t,(c=o())!=null?c:g),s(y,!0),S()}).then(()=>{l==null||l(y,void 0),m=!0,h.forEach(t=>t(y))}).catch(t=>{l==null||l(void 0,t)})};return i.persist={setOptions:n=>{e={...e,...n},n.getStorage&&(d=n.getStorage())},clearStorage:()=>{d==null||d.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>r(),hasHydrated:()=>m,onHydrate:n=>(f.add(n),()=>{f.delete(n)}),onFinishHydration:n=>(h.add(n),()=>{h.delete(n)})},r(),y||g},H=(a,u)=>(s,o,i)=>{let e={storage:b(()=>localStorage),partialize:r=>r,version:0,merge:(r,n)=>({...n,...r}),...u},m=!1;const f=new Set,h=new Set;let d=e.storage;if(!d)return a((...r)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),s(...r)},o,i);const p=()=>{const r=e.partialize({...o()});return d.setItem(e.name,{state:r,version:e.version})},S=i.setState;i.setState=(r,n)=>{S(r,n),p()};const v=a((...r)=>{s(...r),p()},o,i);let g;const y=()=>{var r,n;if(!d)return;m=!1,f.forEach(t=>{var c;return t((c=o())!=null?c:v)});const l=((n=e.onRehydrateStorage)==null?void 0:n.call(e,(r=o())!=null?r:v))||void 0;return I(d.getItem.bind(d))(e.name).then(t=>{if(t)if(typeof t.version=="number"&&t.version!==e.version){if(e.migrate)return e.migrate(t.state,t.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return t.state}).then(t=>{var c;return g=e.merge(t,(c=o())!=null?c:v),s(g,!0),p()}).then(()=>{l==null||l(g,void 0),g=o(),m=!0,h.forEach(t=>t(g))}).catch(t=>{l==null||l(void 0,t)})};return i.persist={setOptions:r=>{e={...e,...r},r.storage&&(d=r.storage)},clearStorage:()=>{d==null||d.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>y(),hasHydrated:()=>m,onHydrate:r=>(f.add(r),()=>{f.delete(r)}),onFinishHydration:r=>(h.add(r),()=>{h.delete(r)})},e.skipHydration||y(),g||v},E=(a,u)=>"getStorage"in u||"serialize"in u||"deserialize"in u?((_?"production":void 0)!=="production"&&console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),w(a,u)):H(a,u),R=E;export{b as c,R as p};
//# sourceMappingURL=middleware-DWkoLS6u.js.map
