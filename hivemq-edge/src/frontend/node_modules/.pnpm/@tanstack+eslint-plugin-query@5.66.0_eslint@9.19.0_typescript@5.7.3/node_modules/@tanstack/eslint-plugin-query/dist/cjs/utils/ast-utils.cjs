"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const utils = require("@typescript-eslint/utils");
const uniqueBy = require("./unique-by.cjs");
const ASTUtils = {
  isNodeOfOneOf(node, types) {
    return types.includes(node.type);
  },
  isIdentifier(node) {
    return node.type === utils.AST_NODE_TYPES.Identifier;
  },
  isIdentifierWithName(node, name) {
    return ASTUtils.isIdentifier(node) && node.name === name;
  },
  isIdentifierWithOneOfNames(node, name) {
    return ASTUtils.isIdentifier(node) && name.includes(node.name);
  },
  isProperty(node) {
    return node.type === utils.AST_NODE_TYPES.Property;
  },
  isObjectExpression(node) {
    return node.type === utils.AST_NODE_TYPES.ObjectExpression;
  },
  isPropertyWithIdentifierKey(node, key) {
    return ASTUtils.isProperty(node) && ASTUtils.isIdentifierWithName(node.key, key);
  },
  findPropertyWithIdentifierKey(properties, key) {
    return properties.find(
      (x) => ASTUtils.isPropertyWithIdentifierKey(x, key)
    );
  },
  getNestedIdentifiers(node) {
    const identifiers = [];
    if (ASTUtils.isIdentifier(node)) {
      identifiers.push(node);
    }
    if ("arguments" in node) {
      node.arguments.forEach((x) => {
        identifiers.push(...ASTUtils.getNestedIdentifiers(x));
      });
    }
    if ("elements" in node) {
      node.elements.forEach((x) => {
        if (x !== null) {
          identifiers.push(...ASTUtils.getNestedIdentifiers(x));
        }
      });
    }
    if ("properties" in node) {
      node.properties.forEach((x) => {
        identifiers.push(...ASTUtils.getNestedIdentifiers(x));
      });
    }
    if ("expressions" in node) {
      node.expressions.forEach((x) => {
        identifiers.push(...ASTUtils.getNestedIdentifiers(x));
      });
    }
    if ("left" in node) {
      identifiers.push(...ASTUtils.getNestedIdentifiers(node.left));
    }
    if ("right" in node) {
      identifiers.push(...ASTUtils.getNestedIdentifiers(node.right));
    }
    if (node.type === utils.AST_NODE_TYPES.Property) {
      identifiers.push(...ASTUtils.getNestedIdentifiers(node.value));
    }
    if (node.type === utils.AST_NODE_TYPES.SpreadElement) {
      identifiers.push(...ASTUtils.getNestedIdentifiers(node.argument));
    }
    if (node.type === utils.AST_NODE_TYPES.MemberExpression) {
      identifiers.push(...ASTUtils.getNestedIdentifiers(node.object));
    }
    if (node.type === utils.AST_NODE_TYPES.UnaryExpression) {
      identifiers.push(...ASTUtils.getNestedIdentifiers(node.argument));
    }
    if (node.type === utils.AST_NODE_TYPES.ChainExpression) {
      identifiers.push(...ASTUtils.getNestedIdentifiers(node.expression));
    }
    if (node.type === utils.AST_NODE_TYPES.TSNonNullExpression) {
      identifiers.push(...ASTUtils.getNestedIdentifiers(node.expression));
    }
    if (node.type === utils.AST_NODE_TYPES.ArrowFunctionExpression) {
      identifiers.push(...ASTUtils.getNestedIdentifiers(node.body));
    }
    if (node.type === utils.AST_NODE_TYPES.FunctionExpression) {
      identifiers.push(...ASTUtils.getNestedIdentifiers(node.body));
    }
    if (node.type === utils.AST_NODE_TYPES.BlockStatement) {
      identifiers.push(
        ...node.body.map((body) => ASTUtils.getNestedIdentifiers(body)).flat()
      );
    }
    if (node.type === utils.AST_NODE_TYPES.ReturnStatement && node.argument) {
      identifiers.push(...ASTUtils.getNestedIdentifiers(node.argument));
    }
    return identifiers;
  },
  isAncestorIsCallee(identifier) {
    let previousNode = identifier;
    let currentNode = identifier.parent;
    while (currentNode !== void 0) {
      if (currentNode.type === utils.AST_NODE_TYPES.CallExpression && currentNode.callee === previousNode) {
        return true;
      }
      if (currentNode.type !== utils.AST_NODE_TYPES.MemberExpression) {
        return false;
      }
      previousNode = currentNode;
      currentNode = currentNode.parent;
    }
    return false;
  },
  traverseUpOnly(identifier, allowedNodeTypes) {
    const parent = identifier.parent;
    if (parent !== void 0 && allowedNodeTypes.includes(parent.type)) {
      return ASTUtils.traverseUpOnly(parent, allowedNodeTypes);
    }
    return identifier;
  },
  isDeclaredInNode(params) {
    const { functionNode, reference, scopeManager } = params;
    const scope = scopeManager.acquire(functionNode);
    if (scope === null) {
      return false;
    }
    return scope.set.has(reference.identifier.name);
  },
  getExternalRefs(params) {
    const { scopeManager, sourceCode, node } = params;
    const scope = scopeManager.acquire(node);
    if (scope === null) {
      return [];
    }
    const references = scope.references.filter((x) => x.isRead() && !scope.set.has(x.identifier.name)).map((x) => {
      const referenceNode = ASTUtils.traverseUpOnly(x.identifier, [
        utils.AST_NODE_TYPES.MemberExpression,
        utils.AST_NODE_TYPES.Identifier
      ]);
      return {
        variable: x,
        node: referenceNode,
        text: sourceCode.getText(referenceNode)
      };
    });
    const localRefIds = new Set(
      [...scope.set.values()].map((x) => sourceCode.getText(x.identifiers[0]))
    );
    const externalRefs = references.filter(
      (x) => x.variable.resolved === null || !localRefIds.has(x.text)
    );
    return uniqueBy.uniqueBy(externalRefs, (x) => x.text).map((x) => x.variable);
  },
  mapKeyNodeToText(node, sourceCode) {
    return sourceCode.getText(
      ASTUtils.traverseUpOnly(node, [
        utils.AST_NODE_TYPES.MemberExpression,
        utils.AST_NODE_TYPES.TSNonNullExpression,
        utils.AST_NODE_TYPES.Identifier
      ])
    );
  },
  mapKeyNodeToBaseText(node, sourceCode) {
    return ASTUtils.mapKeyNodeToText(node, sourceCode).replace(
      /(?:\?(\.)|!)/g,
      "$1"
    );
  },
  isValidReactComponentOrHookName(identifier) {
    return identifier !== null && identifier !== void 0 && /^(use|[A-Z])/.test(identifier.name);
  },
  getFunctionAncestor(sourceCode, node) {
    var _a;
    for (const ancestor of sourceCode.getAncestors(node)) {
      if (ASTUtils.isNodeOfOneOf(ancestor, [
        utils.AST_NODE_TYPES.FunctionDeclaration,
        utils.AST_NODE_TYPES.FunctionExpression,
        utils.AST_NODE_TYPES.ArrowFunctionExpression
      ])) {
        return ancestor;
      }
      if (((_a = ancestor.parent) == null ? void 0 : _a.type) === utils.AST_NODE_TYPES.VariableDeclarator && ancestor.parent.id.type === utils.AST_NODE_TYPES.Identifier && ASTUtils.isNodeOfOneOf(ancestor, [
        utils.AST_NODE_TYPES.FunctionDeclaration,
        utils.AST_NODE_TYPES.FunctionExpression,
        utils.AST_NODE_TYPES.ArrowFunctionExpression
      ])) {
        return ancestor;
      }
    }
    return void 0;
  },
  getReferencedExpressionByIdentifier(params) {
    var _a, _b, _c;
    const { node, context } = params;
    const sourceCode = context.sourceCode ?? context.getSourceCode();
    const scope = context.sourceCode.getScope(node) ? sourceCode.getScope(node) : context.getScope();
    const resolvedNode = (_c = (_b = (_a = scope.references.find((ref) => ref.identifier === node)) == null ? void 0 : _a.resolved) == null ? void 0 : _b.defs[0]) == null ? void 0 : _c.node;
    if ((resolvedNode == null ? void 0 : resolvedNode.type) !== utils.AST_NODE_TYPES.VariableDeclarator) {
      return null;
    }
    return resolvedNode.init;
  },
  getClosestVariableDeclarator(node) {
    let currentNode = node;
    while (currentNode.type !== utils.AST_NODE_TYPES.Program) {
      if (currentNode.type === utils.AST_NODE_TYPES.VariableDeclarator) {
        return currentNode;
      }
      currentNode = currentNode.parent;
    }
    return void 0;
  },
  getNestedReturnStatements(node) {
    const returnStatements = [];
    if (node.type === utils.AST_NODE_TYPES.ReturnStatement) {
      returnStatements.push(node);
    }
    if ("body" in node && node.body !== void 0 && node.body !== null) {
      Array.isArray(node.body) ? node.body.forEach((x) => {
        returnStatements.push(...ASTUtils.getNestedReturnStatements(x));
      }) : returnStatements.push(
        ...ASTUtils.getNestedReturnStatements(node.body)
      );
    }
    if ("consequent" in node) {
      Array.isArray(node.consequent) ? node.consequent.forEach((x) => {
        returnStatements.push(...ASTUtils.getNestedReturnStatements(x));
      }) : returnStatements.push(
        ...ASTUtils.getNestedReturnStatements(node.consequent)
      );
    }
    if ("alternate" in node && node.alternate !== null) {
      Array.isArray(node.alternate) ? node.alternate.forEach((x) => {
        returnStatements.push(...ASTUtils.getNestedReturnStatements(x));
      }) : returnStatements.push(
        ...ASTUtils.getNestedReturnStatements(node.alternate)
      );
    }
    if ("cases" in node) {
      node.cases.forEach((x) => {
        returnStatements.push(...ASTUtils.getNestedReturnStatements(x));
      });
    }
    if ("block" in node) {
      returnStatements.push(...ASTUtils.getNestedReturnStatements(node.block));
    }
    if ("handler" in node && node.handler !== null) {
      returnStatements.push(...ASTUtils.getNestedReturnStatements(node.handler));
    }
    if ("finalizer" in node && node.finalizer !== null) {
      returnStatements.push(
        ...ASTUtils.getNestedReturnStatements(node.finalizer)
      );
    }
    if ("expression" in node && node.expression !== true && node.expression !== false) {
      returnStatements.push(
        ...ASTUtils.getNestedReturnStatements(node.expression)
      );
    }
    if ("test" in node && node.test !== null) {
      returnStatements.push(...ASTUtils.getNestedReturnStatements(node.test));
    }
    return returnStatements;
  }
};
exports.ASTUtils = ASTUtils;
//# sourceMappingURL=ast-utils.cjs.map
