{"version":3,"file":"ast-utils.js","sources":["../../../src/utils/ast-utils.ts"],"sourcesContent":["import { AST_NODE_TYPES } from '@typescript-eslint/utils'\nimport { uniqueBy } from './unique-by'\nimport type { TSESLint, TSESTree } from '@typescript-eslint/utils'\n\nexport const ASTUtils = {\n  isNodeOfOneOf<T extends AST_NODE_TYPES>(\n    node: TSESTree.Node,\n    types: ReadonlyArray<T>,\n  ): node is TSESTree.Node & { type: T } {\n    return types.includes(node.type as T)\n  },\n  isIdentifier(node: TSESTree.Node): node is TSESTree.Identifier {\n    return node.type === AST_NODE_TYPES.Identifier\n  },\n  isIdentifierWithName(\n    node: TSESTree.Node,\n    name: string,\n  ): node is TSESTree.Identifier {\n    return ASTUtils.isIdentifier(node) && node.name === name\n  },\n  isIdentifierWithOneOfNames<T extends Array<string>>(\n    node: TSESTree.Node,\n    name: T,\n  ): node is TSESTree.Identifier & { name: T[number] } {\n    return ASTUtils.isIdentifier(node) && name.includes(node.name)\n  },\n  isProperty(node: TSESTree.Node): node is TSESTree.Property {\n    return node.type === AST_NODE_TYPES.Property\n  },\n  isObjectExpression(node: TSESTree.Node): node is TSESTree.ObjectExpression {\n    return node.type === AST_NODE_TYPES.ObjectExpression\n  },\n  isPropertyWithIdentifierKey(\n    node: TSESTree.Node,\n    key: string,\n  ): node is TSESTree.Property {\n    return (\n      ASTUtils.isProperty(node) && ASTUtils.isIdentifierWithName(node.key, key)\n    )\n  },\n  findPropertyWithIdentifierKey(\n    properties: Array<TSESTree.ObjectLiteralElement>,\n    key: string,\n  ): TSESTree.Property | undefined {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    return properties.find((x) =>\n      ASTUtils.isPropertyWithIdentifierKey(x, key),\n    ) as TSESTree.Property | undefined\n  },\n  getNestedIdentifiers(node: TSESTree.Node): Array<TSESTree.Identifier> {\n    const identifiers: Array<TSESTree.Identifier> = []\n\n    if (ASTUtils.isIdentifier(node)) {\n      identifiers.push(node)\n    }\n\n    if ('arguments' in node) {\n      node.arguments.forEach((x) => {\n        identifiers.push(...ASTUtils.getNestedIdentifiers(x))\n      })\n    }\n\n    if ('elements' in node) {\n      node.elements.forEach((x) => {\n        if (x !== null) {\n          identifiers.push(...ASTUtils.getNestedIdentifiers(x))\n        }\n      })\n    }\n\n    if ('properties' in node) {\n      node.properties.forEach((x) => {\n        identifiers.push(...ASTUtils.getNestedIdentifiers(x))\n      })\n    }\n\n    if ('expressions' in node) {\n      node.expressions.forEach((x) => {\n        identifiers.push(...ASTUtils.getNestedIdentifiers(x))\n      })\n    }\n\n    if ('left' in node) {\n      identifiers.push(...ASTUtils.getNestedIdentifiers(node.left))\n    }\n\n    if ('right' in node) {\n      identifiers.push(...ASTUtils.getNestedIdentifiers(node.right))\n    }\n\n    if (node.type === AST_NODE_TYPES.Property) {\n      identifiers.push(...ASTUtils.getNestedIdentifiers(node.value))\n    }\n\n    if (node.type === AST_NODE_TYPES.SpreadElement) {\n      identifiers.push(...ASTUtils.getNestedIdentifiers(node.argument))\n    }\n\n    if (node.type === AST_NODE_TYPES.MemberExpression) {\n      identifiers.push(...ASTUtils.getNestedIdentifiers(node.object))\n    }\n\n    if (node.type === AST_NODE_TYPES.UnaryExpression) {\n      identifiers.push(...ASTUtils.getNestedIdentifiers(node.argument))\n    }\n\n    if (node.type === AST_NODE_TYPES.ChainExpression) {\n      identifiers.push(...ASTUtils.getNestedIdentifiers(node.expression))\n    }\n\n    if (node.type === AST_NODE_TYPES.TSNonNullExpression) {\n      identifiers.push(...ASTUtils.getNestedIdentifiers(node.expression))\n    }\n\n    if (node.type === AST_NODE_TYPES.ArrowFunctionExpression) {\n      identifiers.push(...ASTUtils.getNestedIdentifiers(node.body))\n    }\n\n    if (node.type === AST_NODE_TYPES.FunctionExpression) {\n      identifiers.push(...ASTUtils.getNestedIdentifiers(node.body))\n    }\n\n    if (node.type === AST_NODE_TYPES.BlockStatement) {\n      identifiers.push(\n        ...node.body.map((body) => ASTUtils.getNestedIdentifiers(body)).flat(),\n      )\n    }\n\n    if (node.type === AST_NODE_TYPES.ReturnStatement && node.argument) {\n      identifiers.push(...ASTUtils.getNestedIdentifiers(node.argument))\n    }\n\n    return identifiers\n  },\n  isAncestorIsCallee(identifier: TSESTree.Node) {\n    let previousNode = identifier\n    let currentNode = identifier.parent\n\n    while (currentNode !== undefined) {\n      if (\n        currentNode.type === AST_NODE_TYPES.CallExpression &&\n        currentNode.callee === previousNode\n      ) {\n        return true\n      }\n\n      if (currentNode.type !== AST_NODE_TYPES.MemberExpression) {\n        return false\n      }\n\n      previousNode = currentNode\n      currentNode = currentNode.parent\n    }\n\n    return false\n  },\n  traverseUpOnly(\n    identifier: TSESTree.Node,\n    allowedNodeTypes: Array<AST_NODE_TYPES>,\n  ): TSESTree.Node {\n    const parent = identifier.parent\n\n    if (parent !== undefined && allowedNodeTypes.includes(parent.type)) {\n      return ASTUtils.traverseUpOnly(parent, allowedNodeTypes)\n    }\n\n    return identifier\n  },\n  isDeclaredInNode(params: {\n    functionNode: TSESTree.Node\n    reference: TSESLint.Scope.Reference\n    scopeManager: TSESLint.Scope.ScopeManager\n  }) {\n    const { functionNode, reference, scopeManager } = params\n    const scope = scopeManager.acquire(functionNode)\n\n    if (scope === null) {\n      return false\n    }\n\n    return scope.set.has(reference.identifier.name)\n  },\n  getExternalRefs(params: {\n    scopeManager: TSESLint.Scope.ScopeManager\n    sourceCode: Readonly<TSESLint.SourceCode>\n    node: TSESTree.Node\n  }): Array<TSESLint.Scope.Reference> {\n    const { scopeManager, sourceCode, node } = params\n    const scope = scopeManager.acquire(node)\n\n    if (scope === null) {\n      return []\n    }\n\n    const references = scope.references\n      .filter((x) => x.isRead() && !scope.set.has(x.identifier.name))\n      .map((x) => {\n        const referenceNode = ASTUtils.traverseUpOnly(x.identifier, [\n          AST_NODE_TYPES.MemberExpression,\n          AST_NODE_TYPES.Identifier,\n        ])\n\n        return {\n          variable: x,\n          node: referenceNode,\n          text: sourceCode.getText(referenceNode),\n        }\n      })\n\n    const localRefIds = new Set(\n      [...scope.set.values()].map((x) => sourceCode.getText(x.identifiers[0])),\n    )\n\n    const externalRefs = references.filter(\n      (x) => x.variable.resolved === null || !localRefIds.has(x.text),\n    )\n\n    return uniqueBy(externalRefs, (x) => x.text).map((x) => x.variable)\n  },\n  mapKeyNodeToText(\n    node: TSESTree.Node,\n    sourceCode: Readonly<TSESLint.SourceCode>,\n  ) {\n    return sourceCode.getText(\n      ASTUtils.traverseUpOnly(node, [\n        AST_NODE_TYPES.MemberExpression,\n        AST_NODE_TYPES.TSNonNullExpression,\n        AST_NODE_TYPES.Identifier,\n      ]),\n    )\n  },\n  mapKeyNodeToBaseText(\n    node: TSESTree.Node,\n    sourceCode: Readonly<TSESLint.SourceCode>,\n  ) {\n    return ASTUtils.mapKeyNodeToText(node, sourceCode).replace(\n      /(?:\\?(\\.)|!)/g,\n      '$1',\n    )\n  },\n  isValidReactComponentOrHookName(\n    identifier: TSESTree.Identifier | null | undefined,\n  ) {\n    return (\n      identifier !== null &&\n      identifier !== undefined &&\n      /^(use|[A-Z])/.test(identifier.name)\n    )\n  },\n  getFunctionAncestor(\n    sourceCode: Readonly<TSESLint.SourceCode>,\n    node: TSESTree.Node,\n  ) {\n    for (const ancestor of sourceCode.getAncestors(node)) {\n      if (\n        ASTUtils.isNodeOfOneOf(ancestor, [\n          AST_NODE_TYPES.FunctionDeclaration,\n          AST_NODE_TYPES.FunctionExpression,\n          AST_NODE_TYPES.ArrowFunctionExpression,\n        ])\n      ) {\n        return ancestor\n      }\n\n      if (\n        ancestor.parent?.type === AST_NODE_TYPES.VariableDeclarator &&\n        ancestor.parent.id.type === AST_NODE_TYPES.Identifier &&\n        ASTUtils.isNodeOfOneOf(ancestor, [\n          AST_NODE_TYPES.FunctionDeclaration,\n          AST_NODE_TYPES.FunctionExpression,\n          AST_NODE_TYPES.ArrowFunctionExpression,\n        ])\n      ) {\n        return ancestor\n      }\n    }\n\n    return undefined\n  },\n  getReferencedExpressionByIdentifier(params: {\n    node: TSESTree.Node\n    context: Readonly<TSESLint.RuleContext<string, ReadonlyArray<unknown>>>\n  }) {\n    const { node, context } = params\n\n    // we need the fallbacks for backwards compat with eslint < 8.37.0\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const sourceCode = context.sourceCode ?? context.getSourceCode()\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const scope = context.sourceCode.getScope(node)\n      ? sourceCode.getScope(node)\n      : context.getScope()\n\n    const resolvedNode = scope.references.find((ref) => ref.identifier === node)\n      ?.resolved?.defs[0]?.node\n\n    if (resolvedNode?.type !== AST_NODE_TYPES.VariableDeclarator) {\n      return null\n    }\n\n    return resolvedNode.init\n  },\n  getClosestVariableDeclarator(node: TSESTree.Node) {\n    let currentNode: TSESTree.Node | undefined = node\n\n    while (currentNode.type !== AST_NODE_TYPES.Program) {\n      if (currentNode.type === AST_NODE_TYPES.VariableDeclarator) {\n        return currentNode\n      }\n\n      currentNode = currentNode.parent\n    }\n\n    return undefined\n  },\n  getNestedReturnStatements(\n    node: TSESTree.Node,\n  ): Array<TSESTree.ReturnStatement> {\n    const returnStatements: Array<TSESTree.ReturnStatement> = []\n\n    if (node.type === AST_NODE_TYPES.ReturnStatement) {\n      returnStatements.push(node)\n    }\n\n    if ('body' in node && node.body !== undefined && node.body !== null) {\n      Array.isArray(node.body)\n        ? node.body.forEach((x) => {\n            returnStatements.push(...ASTUtils.getNestedReturnStatements(x))\n          })\n        : returnStatements.push(\n            ...ASTUtils.getNestedReturnStatements(node.body),\n          )\n    }\n\n    if ('consequent' in node) {\n      Array.isArray(node.consequent)\n        ? node.consequent.forEach((x) => {\n            returnStatements.push(...ASTUtils.getNestedReturnStatements(x))\n          })\n        : returnStatements.push(\n            ...ASTUtils.getNestedReturnStatements(node.consequent),\n          )\n    }\n\n    if ('alternate' in node && node.alternate !== null) {\n      Array.isArray(node.alternate)\n        ? node.alternate.forEach((x) => {\n            returnStatements.push(...ASTUtils.getNestedReturnStatements(x))\n          })\n        : returnStatements.push(\n            ...ASTUtils.getNestedReturnStatements(node.alternate),\n          )\n    }\n\n    if ('cases' in node) {\n      node.cases.forEach((x) => {\n        returnStatements.push(...ASTUtils.getNestedReturnStatements(x))\n      })\n    }\n\n    if ('block' in node) {\n      returnStatements.push(...ASTUtils.getNestedReturnStatements(node.block))\n    }\n\n    if ('handler' in node && node.handler !== null) {\n      returnStatements.push(...ASTUtils.getNestedReturnStatements(node.handler))\n    }\n\n    if ('finalizer' in node && node.finalizer !== null) {\n      returnStatements.push(\n        ...ASTUtils.getNestedReturnStatements(node.finalizer),\n      )\n    }\n\n    if (\n      'expression' in node &&\n      node.expression !== true &&\n      node.expression !== false\n    ) {\n      returnStatements.push(\n        ...ASTUtils.getNestedReturnStatements(node.expression),\n      )\n    }\n\n    if ('test' in node && node.test !== null) {\n      returnStatements.push(...ASTUtils.getNestedReturnStatements(node.test))\n    }\n\n    return returnStatements\n  },\n}\n"],"names":[],"mappings":"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"}