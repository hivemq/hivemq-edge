"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const utils = require("@typescript-eslint/utils");
const astUtils = require("../../utils/ast-utils.cjs");
const getDocsUrl = require("../../utils/get-docs-url.cjs");
const uniqueBy = require("../../utils/unique-by.cjs");
const detectReactQueryImports = require("../../utils/detect-react-query-imports.cjs");
const exhaustiveDeps_utils = require("./exhaustive-deps.utils.cjs");
const QUERY_KEY = "queryKey";
const QUERY_FN = "queryFn";
const name = "exhaustive-deps";
const createRule = utils.ESLintUtils.RuleCreator(getDocsUrl.getDocsUrl);
const rule = createRule({
  name,
  meta: {
    type: "problem",
    docs: {
      description: "Exhaustive deps rule for useQuery",
      recommended: "error"
    },
    messages: {
      missingDeps: `The following dependencies are missing in your queryKey: {{deps}}`,
      fixTo: "Fix to {{result}}"
    },
    hasSuggestions: true,
    fixable: "code",
    schema: []
  },
  defaultOptions: [],
  create: detectReactQueryImports.detectTanstackQueryImports((context) => {
    return {
      Property: (node) => {
        if (!astUtils.ASTUtils.isObjectExpression(node.parent) || !astUtils.ASTUtils.isIdentifierWithName(node.key, QUERY_KEY)) {
          return;
        }
        const scopeManager = context.sourceCode.scopeManager;
        const queryKey = astUtils.ASTUtils.findPropertyWithIdentifierKey(
          node.parent.properties,
          QUERY_KEY
        );
        const queryFn = astUtils.ASTUtils.findPropertyWithIdentifierKey(
          node.parent.properties,
          QUERY_FN
        );
        if (scopeManager === null || queryKey === void 0 || queryFn === void 0 || !astUtils.ASTUtils.isNodeOfOneOf(queryFn.value, [
          utils.AST_NODE_TYPES.ArrowFunctionExpression,
          utils.AST_NODE_TYPES.FunctionExpression,
          utils.AST_NODE_TYPES.ConditionalExpression
        ])) {
          return;
        }
        let queryKeyNode = queryKey.value;
        if (queryKeyNode.type === utils.AST_NODE_TYPES.TSAsExpression && queryKeyNode.expression.type === utils.AST_NODE_TYPES.ArrayExpression) {
          queryKeyNode = queryKeyNode.expression;
        }
        if (queryKeyNode.type === utils.AST_NODE_TYPES.Identifier) {
          const expression = astUtils.ASTUtils.getReferencedExpressionByIdentifier({
            context,
            node: queryKeyNode
          });
          if ((expression == null ? void 0 : expression.type) === utils.AST_NODE_TYPES.ArrayExpression) {
            queryKeyNode = expression;
          }
        }
        const externalRefs = astUtils.ASTUtils.getExternalRefs({
          scopeManager,
          sourceCode: context.sourceCode,
          node: getQueryFnRelevantNode(queryFn)
        });
        const relevantRefs = externalRefs.filter(
          (reference) => exhaustiveDeps_utils.ExhaustiveDepsUtils.isRelevantReference({
            sourceCode: context.sourceCode,
            reference,
            scopeManager,
            node: getQueryFnRelevantNode(queryFn)
          })
        );
        const existingKeys = astUtils.ASTUtils.getNestedIdentifiers(queryKeyNode).map(
          (identifier) => astUtils.ASTUtils.mapKeyNodeToBaseText(identifier, context.sourceCode)
        );
        const missingRefs = relevantRefs.map((ref) => ({
          ref,
          text: astUtils.ASTUtils.mapKeyNodeToBaseText(
            ref.identifier,
            context.sourceCode
          )
        })).filter(({ ref, text }) => {
          return !ref.isTypeReference && !astUtils.ASTUtils.isAncestorIsCallee(ref.identifier) && !existingKeys.some((existingKey) => existingKey === text) && !existingKeys.includes(text.split(/[?.]/)[0] ?? "");
        }).map(({ ref, text }) => ({
          identifier: ref.identifier,
          text
        }));
        const uniqueMissingRefs = uniqueBy.uniqueBy(missingRefs, (x) => x.text);
        if (uniqueMissingRefs.length > 0) {
          const missingAsText = uniqueMissingRefs.map(
            (ref) => astUtils.ASTUtils.mapKeyNodeToText(ref.identifier, context.sourceCode)
          ).join(", ");
          const queryKeyValue = context.sourceCode.getText(queryKeyNode);
          const existingWithMissing = queryKeyValue === "[]" ? `[${missingAsText}]` : queryKeyValue.replace(/\]$/, `, ${missingAsText}]`);
          const suggestions = [];
          if (queryKeyNode.type === utils.AST_NODE_TYPES.ArrayExpression) {
            suggestions.push({
              messageId: "fixTo",
              data: { result: existingWithMissing },
              fix(fixer) {
                return fixer.replaceText(queryKeyNode, existingWithMissing);
              }
            });
          }
          context.report({
            node,
            messageId: "missingDeps",
            data: {
              deps: uniqueMissingRefs.map((ref) => ref.text).join(", ")
            },
            suggest: suggestions
          });
        }
      }
    };
  })
});
function getQueryFnRelevantNode(queryFn) {
  if (queryFn.value.type !== utils.AST_NODE_TYPES.ConditionalExpression) {
    return queryFn.value;
  }
  if (queryFn.value.consequent.type === utils.AST_NODE_TYPES.Identifier && queryFn.value.consequent.name === "skipToken") {
    return queryFn.value.alternate;
  }
  return queryFn.value.consequent;
}
exports.name = name;
exports.rule = rule;
//# sourceMappingURL=exhaustive-deps.rule.cjs.map
