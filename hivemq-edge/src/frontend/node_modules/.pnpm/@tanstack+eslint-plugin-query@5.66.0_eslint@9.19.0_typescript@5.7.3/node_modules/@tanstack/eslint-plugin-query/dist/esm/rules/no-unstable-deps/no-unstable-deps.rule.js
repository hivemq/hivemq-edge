import { ESLintUtils, AST_NODE_TYPES } from "@typescript-eslint/utils";
import { getDocsUrl } from "../../utils/get-docs-url.js";
import { detectTanstackQueryImports } from "../../utils/detect-react-query-imports.js";
const name = "no-unstable-deps";
const reactHookNames = ["useEffect", "useCallback", "useMemo"];
const useQueryHookNames = [
  "useQuery",
  "useSuspenseQuery",
  "useQueries",
  "useSuspenseQueries",
  "useInfiniteQuery",
  "useSuspenseInfiniteQuery"
];
const allHookNames = ["useMutation", ...useQueryHookNames];
const createRule = ESLintUtils.RuleCreator(getDocsUrl);
const rule = createRule({
  name,
  meta: {
    type: "problem",
    docs: {
      description: "Disallow putting the result of query hooks directly in a React hook dependency array",
      recommended: "error"
    },
    messages: {
      noUnstableDeps: `The result of {{queryHook}} is not referentially stable, so don't pass it directly into the dependencies array of {{reactHook}}. Instead, destructure the return value of {{queryHook}} and pass the destructured values into the dependency array of {{reactHook}}.`
    },
    schema: []
  },
  defaultOptions: [],
  create: detectTanstackQueryImports((context) => {
    const trackedVariables = {};
    const hookAliasMap = {};
    function getReactHook(node) {
      if (node.callee.type === "Identifier") {
        const calleeName = node.callee.name;
        if (reactHookNames.includes(calleeName) || calleeName in hookAliasMap) {
          return calleeName;
        }
      } else if (node.callee.type === "MemberExpression" && node.callee.object.type === "Identifier" && node.callee.object.name === "React" && node.callee.property.type === "Identifier" && reactHookNames.includes(node.callee.property.name)) {
        return node.callee.property.name;
      }
      return void 0;
    }
    function collectVariableNames(pattern, queryHook) {
      if (pattern.type === AST_NODE_TYPES.Identifier) {
        trackedVariables[pattern.name] = queryHook;
      }
    }
    return {
      ImportDeclaration(node) {
        if (node.specifiers.length > 0 && node.importKind === "value" && node.source.value === "React") {
          node.specifiers.forEach((specifier) => {
            if (specifier.type === AST_NODE_TYPES.ImportSpecifier && specifier.imported.type === AST_NODE_TYPES.Identifier && reactHookNames.includes(specifier.imported.name)) {
              hookAliasMap[specifier.local.name] = specifier.imported.name;
            }
          });
        }
      },
      VariableDeclarator(node) {
        if (node.init !== null && node.init.type === AST_NODE_TYPES.CallExpression && node.init.callee.type === AST_NODE_TYPES.Identifier && allHookNames.includes(node.init.callee.name)) {
          collectVariableNames(node.id, node.init.callee.name);
        }
      },
      CallExpression: (node) => {
        var _a;
        const reactHook = getReactHook(node);
        if (reactHook !== void 0 && node.arguments.length > 1 && ((_a = node.arguments[1]) == null ? void 0 : _a.type) === AST_NODE_TYPES.ArrayExpression) {
          const depsArray = node.arguments[1].elements;
          depsArray.forEach((dep) => {
            if (dep !== null && dep.type === AST_NODE_TYPES.Identifier && trackedVariables[dep.name] !== void 0) {
              const queryHook = trackedVariables[dep.name];
              context.report({
                node: dep,
                messageId: "noUnstableDeps",
                data: {
                  queryHook,
                  reactHook
                }
              });
            }
          });
        }
      }
    };
  })
});
export {
  name,
  reactHookNames,
  rule,
  useQueryHookNames
};
//# sourceMappingURL=no-unstable-deps.rule.js.map
