"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isMatching = exports.match = exports.instanceOf = exports.select = exports.not = exports.when = exports.__ = void 0;
const symbols = require("./symbols");
const guards_1 = require("./guards");
Object.defineProperty(exports, "when", { enumerable: true, get: function () { return guards_1.when; } });
Object.defineProperty(exports, "not", { enumerable: true, get: function () { return guards_1.not; } });
Object.defineProperty(exports, "select", { enumerable: true, get: function () { return guards_1.select; } });
Object.defineProperty(exports, "instanceOf", { enumerable: true, get: function () { return guards_1.instanceOf; } });
const wildcards_1 = require("./wildcards");
Object.defineProperty(exports, "__", { enumerable: true, get: function () { return wildcards_1.__; } });
/**
 * #### match
 *
 * Entry point to create a pattern matching expression.
 *
 * It returns a `Match` builder, on which you can chain
 * several `.with(pattern, handler)` clauses.
 */
const match = (value) => builder(value, []);
exports.match = match;
/**
 * ### builder
 * This is the implementation of our pattern matching, using the
 * builder pattern.
 */
const builder = (value, cases) => {
    const run = () => {
        const entry = cases.find(({ test }) => test(value));
        if (!entry) {
            let displayedValue;
            try {
                displayedValue = JSON.stringify(value);
            }
            catch (e) {
                displayedValue = value;
            }
            throw new Error(`Pattern matching error: no pattern matches value ${displayedValue}`);
        }
        return entry.handler(entry.select(value), value);
    };
    return {
        with(...args) {
            const handler = args[args.length - 1];
            const patterns = [];
            const predicates = [];
            for (let i = 0; i < args.length - 1; i++) {
                const arg = args[i];
                if (typeof arg === 'function') {
                    predicates.push(arg);
                }
                else {
                    patterns.push(arg);
                }
            }
            let selected = {};
            const doesMatch = (value) => Boolean(patterns.some((pattern) => matchPattern(pattern, value, (key, value) => {
                selected[key] = value;
            })) && predicates.every((predicate) => predicate(value)));
            return builder(value, cases.concat([
                {
                    test: doesMatch,
                    handler,
                    select: (value) => Object.keys(selected).length
                        ? symbols.AnonymousSelectKey in selected
                            ? selected[symbols.AnonymousSelectKey]
                            : selected
                        : value,
                },
            ]));
        },
        when: (predicate, handler) => builder(value, cases.concat([
            {
                test: predicate,
                handler,
                select: (value) => value,
            },
        ])),
        otherwise: (handler) => builder(value, cases.concat([
            {
                test: () => true,
                handler,
                select: (value) => value,
            },
        ])).run(),
        exhaustive: () => run(),
        run,
    };
};
const isObject = (value) => Boolean(value && typeof value === 'object');
const isGuardPattern = (x) => {
    const pattern = x;
    return pattern && pattern[symbols.PatternKind] === symbols.Guard;
};
const isNotPattern = (x) => {
    const pattern = x;
    return pattern && pattern[symbols.PatternKind] === symbols.Not;
};
const isSelectPattern = (x) => {
    const pattern = x;
    return pattern && pattern[symbols.PatternKind] === symbols.Select;
};
// tells us if the value matches a given pattern.
const matchPattern = (pattern, value, select) => {
    if (isObject(pattern)) {
        if (isGuardPattern(pattern))
            return Boolean(pattern[symbols.Guard](value));
        if (isSelectPattern(pattern)) {
            select(pattern[symbols.Select], value);
            return true;
        }
        if (isNotPattern(pattern))
            return !matchPattern(pattern[symbols.Not], value, select);
        if (!isObject(value))
            return false;
        if (Array.isArray(pattern)) {
            if (!Array.isArray(value))
                return false;
            // List pattern
            if (pattern.length === 1) {
                const selected = {};
                const listSelect = (key, value) => {
                    selected[key] = (selected[key] || []).concat([value]);
                };
                const doesMatch = value.every((v) => matchPattern(pattern[0], v, listSelect));
                if (doesMatch) {
                    Object.keys(selected).forEach((key) => select(key, selected[key]));
                }
                return doesMatch;
            }
            // Tuple pattern
            return pattern.length === value.length
                ? pattern.every((subPattern, i) => matchPattern(subPattern, value[i], select))
                : false;
        }
        if (pattern instanceof Map) {
            if (!(value instanceof Map))
                return false;
            return [...pattern.keys()].every((key) => matchPattern(pattern.get(key), value.get(key), select));
        }
        if (pattern instanceof Set) {
            if (!(value instanceof Set))
                return false;
            if (pattern.size === 0)
                return value.size === 0;
            if (pattern.size === 1) {
                const [subPattern] = [...pattern.values()];
                return Object.values(wildcards_1.__).includes(subPattern)
                    ? matchPattern([subPattern], [...value.values()], select)
                    : value.has(subPattern);
            }
            return [...pattern.values()].every((subPattern) => value.has(subPattern));
        }
        return Object.keys(pattern).every((k) => k in value &&
            matchPattern(
            // @ts-ignore
            pattern[k], 
            // @ts-ignore
            value[k], select));
    }
    return value === pattern;
};
function isMatching(...args) {
    if (args.length === 1) {
        const [pattern] = args;
        return (value) => matchPattern(pattern, value, () => { });
    }
    if (args.length === 2) {
        const [pattern, value] = args;
        return matchPattern(pattern, value, () => { });
    }
    throw new Error(`isMatching wasn't given enough arguments: expected 1 or 2, received ${args.length}.`);
}
exports.isMatching = isMatching;
