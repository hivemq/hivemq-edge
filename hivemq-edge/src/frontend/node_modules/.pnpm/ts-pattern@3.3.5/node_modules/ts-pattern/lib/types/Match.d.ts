import type { Pattern, GuardValue, GuardPattern } from './Pattern';
import type { ExtractPreciseValue } from './ExtractPreciseValue';
import type { InvertPatternForExclude, InvertPattern } from './InvertPattern';
import type { DeepExclude } from './DeepExclude';
import type { WithDefault, Union } from './helpers';
import type { FindSelected } from './FindSelected';
export declare type MatchedValue<a, invpattern> = WithDefault<ExtractPreciseValue<a, invpattern>, a>;
export declare type Unset = '@ts-pattern/unset';
export declare type PickReturnValue<a, b> = a extends Unset ? b : a;
declare type NonExhaustiveError<i> = {
    __nonExhaustive: never;
} & i;
/**
 * #### Match
 * An interface to create a pattern matching clause.
 */
export declare type Match<i, o, patternValueTuples extends [any, any] = never, inferredOutput = never> = {
    /**
     * #### Match.with
     *
     * If the input matches the pattern provided as first argument,
     * execute the handler function and return its result.
     **/
    with<p extends Pattern<i>, c, value extends MatchedValue<i, InvertPattern<p>>>(pattern: p, handler: (selections: FindSelected<value, p>, value: value) => PickReturnValue<o, c>): Match<i, o, patternValueTuples | [p, value], Union<inferredOutput, c>>;
    with<p1 extends Pattern<i>, p2 extends Pattern<i>, c, p extends p1 | p2, value extends p extends any ? MatchedValue<i, InvertPattern<p>> : never>(pattern1: p1, pattern2: p2, handler: (value: value) => PickReturnValue<o, c>): Match<i, o, patternValueTuples | (p extends any ? [p, value] : never), Union<inferredOutput, c>>;
    with<pat extends Pattern<i>, pred extends (value: MatchedValue<i, InvertPattern<pat>>) => unknown, c, value extends GuardValue<pred>>(pattern: pat, predicate: pred, handler: (selections: FindSelected<value, pat>, value: value) => PickReturnValue<o, c>): Match<i, o, patternValueTuples | (pred extends (value: any) => value is infer narrowed ? [GuardPattern<unknown, narrowed>, value] : never), Union<inferredOutput, c>>;
    with<ps extends [Pattern<i>, ...Pattern<i>[]], c, p extends ps[number], value extends p extends any ? MatchedValue<i, InvertPattern<p>> : never>(...args: [...patterns: ps, handler: (value: value) => PickReturnValue<o, c>]): Match<i, o, patternValueTuples | (p extends any ? [p, value] : never), Union<inferredOutput, c>>;
    /**
     * #### Match.when
     *
     * When the first function returns a truthy value,
     * execute the handler function and return its result.
     **/
    when<pred extends (value: i) => unknown, c, value extends GuardValue<pred>>(predicate: pred, handler: (value: value) => PickReturnValue<o, c>): Match<i, o, patternValueTuples | (pred extends (value: any) => value is infer narrowed ? [GuardPattern<unknown, narrowed>, value] : never), Union<inferredOutput, c>>;
    /**
     * #### Match.otherwise
     *
     * takes a function returning the **default value**.
     * and return the result of the pattern matching expression.
     *
     * Equivalent to `.with(__, () => x).run()`
     **/
    otherwise<c>(handler: (value: i) => PickReturnValue<o, c>): PickReturnValue<o, Union<inferredOutput, c>>;
    /**
     * #### Match.exhaustive
     *
     * Runs the pattern matching expression and return the result value.
     *
     * If this is of type `NonExhaustiveError`, it means you aren't matching
     * every cases, and you should probably add another `.with(...)` clause
     * to prevent potential runtime errors.
     *
     * */
    exhaustive: DeepExcludeAll<i, patternValueTuples> extends infer remainingCases ? [remainingCases] extends [never] ? () => PickReturnValue<o, inferredOutput> : NonExhaustiveError<remainingCases> : never;
    /**
     * #### Match.run
     * Runs the pattern matching expression and return the result.
     * */
    run(): PickReturnValue<o, inferredOutput>;
};
declare type DeepExcludeAll<a, tuple extends [any, any]> = DeepExclude<a, tuple extends any ? InvertPatternForExclude<tuple[0], tuple[1]> : never>;
export {};
