export declare type ValueOf<a> = a extends any[] ? a[number] : a[keyof a];
export declare type Values<a extends object> = UnionToTuple<ValueOf<a>>;
/**
 * ### LeastUpperBound
 * An interesting one. A type taking two imbricated sets and returning the
 * smallest one.
 * We need that because sometimes the pattern's infered type holds more
 * information than the value on which we are matching (if the value is any
 * or unknown for instance).
 */
export declare type LeastUpperBound<a, b> = b extends a ? b : a extends b ? a : never;
/**
 * if a key of an object has the never type,
 * returns never, otherwise returns the type of object
 **/
export declare type ExcludeIfContainsNever<a, b> = b extends Map<any, any> | Set<any> ? a : b extends readonly [any, ...any] ? ExcludeObjectIfContainsNever<a, keyof b & ('0' | '1' | '2' | '3' | '4')> : b extends any[] ? ExcludeObjectIfContainsNever<a, keyof b & number> : ExcludeObjectIfContainsNever<a, keyof b & string>;
export declare type ExcludeObjectIfContainsNever<a, keyConstraint = unknown> = a extends any ? {
    [k in keyConstraint & keyof a]-?: [a[k]] extends [never] ? 'exclude' : 'include';
}[keyConstraint & keyof a] extends infer includeOrExclude ? (includeOrExclude extends 'include' ? 'include' extends includeOrExclude ? true : false : false) extends true ? a : never : never : never;
export declare type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
export declare type IsUnion<a> = [a] extends [UnionToIntersection<a>] ? false : true;
export declare type UnionToTuple<T, output extends any[] = []> = UnionToIntersection<T extends any ? (t: T) => T : never> extends (_: any) => infer W ? UnionToTuple<Exclude<T, W>, [W, ...output]> : output;
export declare type Cast<a, b> = a extends b ? a : never;
export declare type Flatten<xs extends any[], output extends any[] = []> = xs extends readonly [infer head, ...infer tail] ? Flatten<tail, [...output, ...Cast<head, any[]>]> : output;
export declare type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? true : false;
export declare type Expect<T extends true> = T;
export declare type IsAny<T> = 0 extends 1 & T ? true : false;
export declare type Length<it extends any[]> = it['length'];
export declare type Iterator<n extends number, it extends any[] = []> = it['length'] extends n ? it : Iterator<n, [any, ...it]>;
export declare type Next<it extends any[]> = [any, ...it];
export declare type Prev<it extends any[]> = it extends readonly [any, ...infer tail] ? tail : [];
export declare type Slice<xs extends readonly any[], it extends any[], output extends any[] = []> = Length<it> extends 0 ? output : xs extends readonly [infer head, ...infer tail] ? Slice<tail, Prev<it>, [...output, head]> : output;
export declare type Drop<xs extends readonly any[], n extends any[]> = Length<n> extends 0 ? xs : xs extends readonly [any, ...infer tail] ? Drop<tail, Prev<n>> : [];
export declare type BuiltInObjects = Function | Date | RegExp | Generator | {
    readonly [Symbol.toStringTag]: string;
};
export declare type IsPlainObject<o, excludeUnion = BuiltInObjects> = o extends object ? o extends string | excludeUnion ? false : true : false;
export declare type Compute<a extends any> = a extends BuiltInObjects ? a : {
    [k in keyof a]: a[k];
} & unknown;
export declare type All<xs> = xs extends readonly [infer head, ...infer tail] ? boolean extends head ? false : head extends true ? All<tail> : false : true;
export declare type Or<a extends boolean, b extends boolean> = true extends a | b ? true : false;
export declare type WithDefault<a, def> = [a] extends [never] ? def : a;
export declare type IsLiteral<T> = T extends null | undefined ? true : T extends string ? string extends T ? false : true : T extends number ? number extends T ? false : true : T extends boolean ? boolean extends T ? false : true : T extends symbol ? symbol extends T ? false : true : T extends bigint ? bigint extends T ? false : true : false;
export declare type Primitives = number | boolean | string | undefined | null | symbol | bigint;
export declare type Union<a, b> = [b] extends [a] ? a : [a] extends [b] ? b : a | b;
