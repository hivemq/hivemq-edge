import type { Pattern } from './types/Pattern';
import type { Match, MatchedValue } from './types/Match';
import { when, not, select, instanceOf } from './guards';
import { __ } from './wildcards';
import { InvertPattern } from './types/InvertPattern';
/**
 * # Pattern matching
 **/
export { Pattern, __, when, not, select, instanceOf };
/**
 * #### match
 *
 * Entry point to create a pattern matching expression.
 *
 * It returns a `Match` builder, on which you can chain
 * several `.with(pattern, handler)` clauses.
 */
export declare const match: <i, o = "@ts-pattern/unset">(value: i) => Match<i, o, never, never>;
/**
 * Helper function taking a pattern and returning a **type guard** function telling
 * us whether or not a value matches the pattern.
 *
 * @param pattern the Pattern the value should match
 * @returns a function taking the value and returning whether or not it matches the pattern.
 */
export declare function isMatching<p extends Pattern<any>>(pattern: p): (value: any) => value is MatchedValue<any, InvertPattern<p>>;
/**
 * **type guard** function taking a pattern and a value and returning a boolean telling
 * us whether or not the value matches the pattern.
 *
 * @param pattern the Pattern the value should match
 * @param value
 * @returns a boolean telling whether or not the value matches the pattern.
 */
export declare function isMatching<p extends Pattern<any>>(pattern: p, value: any): value is MatchedValue<any, InvertPattern<p>>;
