{"version":3,"file":"nivo-voronoi.es.js","sources":["../src/props.ts","../src/defaults.ts","../src/computeMesh.ts","../src/hooks.ts","../src/Voronoi.tsx","../src/ResponsiveVoronoi.tsx","../src/Mesh.tsx","../src/meshCanvas.ts"],"sourcesContent":["import { VoronoiDomain, VoronoiLayer } from './types'\n\nexport const defaultVoronoiProps = {\n    xDomain: [0, 1] as VoronoiDomain,\n    yDomain: [0, 1] as VoronoiDomain,\n    layers: ['links', 'cells', 'points', 'bounds'] as VoronoiLayer[],\n    enableLinks: false,\n    linkLineWidth: 1,\n    linkLineColor: '#bbbbbb',\n    enableCells: true,\n    cellLineWidth: 2,\n    cellLineColor: '#000000',\n    enablePoints: true,\n    pointSize: 4,\n    pointColor: '#666666',\n    role: 'img',\n}\n","import { Margin, defaultMargin as coreDefaultMargin } from '@nivo/core'\nimport { TooltipAnchor, TooltipPosition } from '@nivo/tooltip'\n\nexport const defaultNodePositionAccessor = (node: {\n    x: number\n    y: number\n}): [x: number, y: number] => [node.x, node.y]\n\nexport const defaultMargin: Margin = coreDefaultMargin\n\nexport const defaultTooltipPosition: TooltipPosition = 'cursor'\nexport const defaultTooltipAnchor: TooltipAnchor = 'top'\n","import { Delaunay } from 'd3-delaunay'\nimport { Margin } from '@nivo/core'\nimport { NodePositionAccessor } from './types'\nimport { defaultNodePositionAccessor, defaultMargin } from './defaults'\n\n/**\n * The delaunay generator requires an array\n * where each point is defined as an array\n * of 2 elements: [x: number, y: number].\n *\n * Points represent the raw input data\n * and x/y represent accessors to x & y.\n */\nexport const computeMeshPoints = <Node>({\n    points,\n    getNodePosition = defaultNodePositionAccessor as NodePositionAccessor<Node>,\n    margin = defaultMargin,\n}: {\n    points: readonly Node[]\n    getNodePosition?: NodePositionAccessor<Node>\n    margin?: Margin\n}): [number, number][] => {\n    return points.map(node => {\n        const [x, y] = getNodePosition(node)\n\n        return [x + margin.left, y + margin.top]\n    })\n}\n\nexport const computeMesh = ({\n    points,\n    width,\n    height,\n    margin = defaultMargin,\n    debug,\n}: {\n    points: readonly [number, number][]\n    width: number\n    height: number\n    margin?: Margin\n    debug?: boolean\n}) => {\n    const delaunay = Delaunay.from(points)\n    const voronoi = debug\n        ? delaunay.voronoi([\n              0,\n              0,\n              margin.left + width + margin.right,\n              margin.top + height + margin.bottom,\n          ])\n        : undefined\n\n    return { points, delaunay, voronoi }\n}\n","import {\n    MouseEvent,\n    MutableRefObject,\n    TouchEvent,\n    useCallback,\n    useEffect,\n    useMemo,\n    useRef,\n    useState,\n} from 'react'\nimport { scaleLinear } from 'd3-scale'\nimport { Delaunay } from 'd3-delaunay'\nimport { getDistance, getRelativeCursor, Margin } from '@nivo/core'\nimport { TooltipAnchor, TooltipPosition, useTooltip } from '@nivo/tooltip'\nimport { computeMeshPoints, computeMesh } from './computeMesh'\nimport {\n    VoronoiCommonProps,\n    VoronoiDatum,\n    VoronoiCustomLayerProps,\n    NodeMouseHandler,\n    // DatumTouchHandler,\n    NodePositionAccessor,\n    NodeTouchHandler,\n} from './types'\nimport {\n    defaultMargin,\n    defaultNodePositionAccessor,\n    defaultTooltipPosition,\n    defaultTooltipAnchor,\n} from './defaults'\n\nexport const useVoronoiMesh = <Node>({\n    points,\n    getNodePosition = defaultNodePositionAccessor as NodePositionAccessor<Node>,\n    width,\n    height,\n    margin = defaultMargin,\n    debug,\n}: {\n    points: readonly Node[]\n    getNodePosition?: NodePositionAccessor<Node>\n    // Margins are added to the chart's dimensions, so that mouse detection\n    // also works inside the margins, omit if that's not what you want.\n    // When including the margins, we recommend to set a `detectionRadius` as well.\n    margin?: Margin\n    width: number\n    height: number\n    debug?: boolean\n}) =>\n    useMemo(\n        () =>\n            computeMesh({\n                points: computeMeshPoints<Node>({ points, margin, getNodePosition }),\n                width,\n                height,\n                margin,\n                debug,\n            }),\n        [points, width, height, margin, debug]\n    )\n\nexport const useVoronoi = ({\n    data,\n    width,\n    height,\n    xDomain,\n    yDomain,\n}: {\n    data: VoronoiDatum[]\n    width: number\n    height: number\n    xDomain: VoronoiCommonProps['xDomain']\n    yDomain: VoronoiCommonProps['yDomain']\n}) => {\n    const xScale = useMemo(() => scaleLinear().domain(xDomain).range([0, width]), [xDomain, width])\n    const yScale = useMemo(\n        () => scaleLinear().domain(yDomain).range([0, height]),\n        [yDomain, height]\n    )\n\n    const points = useMemo(\n        () =>\n            data.map(d => ({\n                x: xScale(d.x),\n                y: yScale(d.y),\n                data: d,\n            })),\n        [data, xScale, yScale]\n    )\n\n    return useMemo(() => {\n        const delaunay = Delaunay.from(points.map(p => [p.x, p.y]))\n        const voronoi = delaunay.voronoi([0, 0, width, height])\n\n        return {\n            points,\n            delaunay,\n            voronoi,\n        }\n    }, [points, width, height])\n}\n\n/**\n * Memoize the context to pass to custom layers.\n */\nexport const useVoronoiLayerContext = ({\n    points,\n    delaunay,\n    voronoi,\n}: VoronoiCustomLayerProps): VoronoiCustomLayerProps =>\n    useMemo(\n        () => ({\n            points,\n            delaunay,\n            voronoi,\n        }),\n        [points, delaunay, voronoi]\n    )\n\nexport const useMeshEvents = <Node, ElementType extends Element>({\n    elementRef,\n    nodes,\n    getNodePosition = defaultNodePositionAccessor as NodePositionAccessor<Node>,\n    delaunay,\n    setCurrent: setCurrentNode,\n    margin = defaultMargin,\n    detectionRadius = Infinity,\n    isInteractive = true,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n    enableTouchCrosshair = false,\n    tooltip,\n    tooltipPosition = defaultTooltipPosition,\n    tooltipAnchor = defaultTooltipAnchor,\n}: {\n    elementRef: MutableRefObject<ElementType | null>\n    nodes: readonly Node[]\n    getNodePosition?: NodePositionAccessor<Node>\n    delaunay: Delaunay<Node>\n    setCurrent?: (node: Node | null) => void\n    margin?: Margin\n    detectionRadius?: number\n    isInteractive?: boolean\n    onMouseEnter?: NodeMouseHandler<Node>\n    onMouseMove?: NodeMouseHandler<Node>\n    onMouseLeave?: NodeMouseHandler<Node>\n    onClick?: NodeMouseHandler<Node>\n    onTouchStart?: NodeTouchHandler<Node>\n    onTouchMove?: NodeTouchHandler<Node>\n    onTouchEnd?: NodeTouchHandler<Node>\n    enableTouchCrosshair?: boolean\n    tooltip?: (node: Node) => JSX.Element\n    tooltipPosition?: TooltipPosition\n    tooltipAnchor?: TooltipAnchor\n}) => {\n    // Store the index of the current point and the current node.\n    const [current, setCurrent] = useState<[number, Node] | null>(null)\n\n    // Keep track of the previous index and node, this is needed as we don't have enter/leave events\n    // for each node because we use a single rect element to capture events.\n    const previous = useRef<[number, Node] | null>(null)\n\n    useEffect(() => {\n        previous.current = current\n    }, [previous, current])\n\n    const findNode = useCallback(\n        (event: MouseEvent<ElementType> | TouchEvent<ElementType>): null | [number, Node] => {\n            if (!elementRef.current) return null\n\n            const [x, y] = getRelativeCursor(elementRef.current, event)\n\n            let index: number | null = delaunay.find(x, y)\n            let node = index !== undefined ? nodes[index] : null\n\n            if (node && detectionRadius !== Infinity) {\n                const [nodeX, nodeY] = getNodePosition(node)\n                if (getDistance(x, y, nodeX + margin.left, nodeY + margin.top) > detectionRadius) {\n                    index = null\n                    node = null\n                }\n            }\n\n            if (index === null || node === null) return null\n\n            return [index, node]\n        },\n        [elementRef, delaunay, nodes, getNodePosition, margin, detectionRadius]\n    )\n\n    const { showTooltipAt, showTooltipFromEvent, hideTooltip } = useTooltip()\n    const showTooltip = useMemo(() => {\n        if (!tooltip) return undefined\n\n        if (tooltipPosition === 'cursor') {\n            // Following the cursor.\n            return (node: Node, event: MouseEvent<ElementType>) => {\n                showTooltipFromEvent(tooltip(node), event, tooltipAnchor)\n            }\n        }\n\n        // Fixed at the node's position.\n        return (node: Node) => {\n            const [x, y] = getNodePosition(node)\n            showTooltipAt(tooltip(node), [x + margin.left, y + margin.top], tooltipAnchor)\n        }\n    }, [\n        showTooltipAt,\n        showTooltipFromEvent,\n        tooltip,\n        tooltipPosition,\n        tooltipAnchor,\n        getNodePosition,\n        margin,\n    ])\n\n    // Mouse enter only occurs when entering the main element,\n    // not for each node.\n    const handleMouseEnter = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            const match = findNode(event)\n\n            setCurrent(match)\n            setCurrentNode?.(match ? match[1] : null)\n\n            if (match) {\n                const node = match[1]\n\n                showTooltip?.(node, event)\n                onMouseEnter?.(match[1], event)\n            }\n        },\n        [findNode, setCurrent, setCurrentNode, showTooltip, onMouseEnter]\n    )\n\n    // Handle mouse enter/move/leave, relying on `previous` to simulate events.\n    const handleMouseMove = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            const match = findNode(event)\n\n            setCurrent(match)\n\n            if (match) {\n                const [index, node] = match\n\n                setCurrentNode?.(node)\n                showTooltip?.(node, event)\n\n                if (previous.current) {\n                    const [previousIndex, previousNode] = previous.current\n                    if (index !== previousIndex) {\n                        // Simulate an enter event if the previous index is different.\n                        onMouseLeave?.(previousNode, event)\n                    } else {\n                        // If it's the same, trigger a regular move event.\n                        onMouseMove?.(node, event)\n                    }\n                } else {\n                    onMouseEnter?.(node, event)\n                }\n            } else {\n                setCurrentNode?.(null)\n                hideTooltip?.()\n\n                if (previous.current) {\n                    // Simulate a leave event if there's a previous node.\n                    onMouseLeave?.(previous.current[1], event)\n                }\n            }\n        },\n        [\n            findNode,\n            setCurrent,\n            previous,\n            onMouseEnter,\n            onMouseMove,\n            onMouseLeave,\n            showTooltip,\n            hideTooltip,\n        ]\n    )\n\n    // Mouse leave only occurs when leaving the main element,\n    // not for each node.\n    const handleMouseLeave = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            setCurrent(null)\n            setCurrentNode?.(null)\n\n            hideTooltip()\n\n            if (onMouseLeave && previous.current) {\n                onMouseLeave(previous.current[1], event)\n            }\n        },\n        [setCurrent, setCurrentNode, previous, hideTooltip, onMouseLeave]\n    )\n\n    const handleClick = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            const match = findNode(event)\n\n            setCurrent(match)\n\n            match && onClick?.(match[1], event)\n        },\n        [findNode, setCurrent, onClick]\n    )\n\n    const handleTouchStart = useCallback(\n        (event: TouchEvent<ElementType>) => {\n            const match = findNode(event)\n\n            if (enableTouchCrosshair) {\n                setCurrent(match)\n                setCurrentNode?.(match ? match[1] : null)\n            }\n\n            match && onTouchStart?.(match[1], event)\n        },\n        [findNode, setCurrent, setCurrentNode, enableTouchCrosshair, onTouchStart]\n    )\n\n    const handleTouchMove = useCallback(\n        (event: TouchEvent<ElementType>) => {\n            const match = findNode(event)\n\n            if (enableTouchCrosshair) {\n                setCurrent(match)\n                setCurrentNode?.(match ? match[1] : null)\n            }\n\n            match && onTouchMove?.(match[1], event)\n        },\n        [findNode, setCurrent, setCurrentNode, enableTouchCrosshair, onTouchMove]\n    )\n\n    const handleTouchEnd = useCallback(\n        (event: TouchEvent<SVGRectElement>) => {\n            if (enableTouchCrosshair) {\n                setCurrent(null)\n                setCurrentNode?.(null)\n            }\n\n            if (onTouchEnd && previous.current) {\n                onTouchEnd(previous.current[1], event)\n            }\n        },\n        [enableTouchCrosshair, setCurrent, setCurrentNode, onTouchEnd, previous]\n    )\n\n    return {\n        current,\n        handleMouseEnter: isInteractive ? handleMouseEnter : undefined,\n        handleMouseMove: isInteractive ? handleMouseMove : undefined,\n        handleMouseLeave: isInteractive ? handleMouseLeave : undefined,\n        handleClick: isInteractive ? handleClick : undefined,\n        handleTouchStart: isInteractive ? handleTouchStart : undefined,\n        handleTouchMove: isInteractive ? handleTouchMove : undefined,\n        handleTouchEnd: isInteractive ? handleTouchEnd : undefined,\n    }\n}\n\n/**\n * Compute a voronoi mesh and corresponding events.\n */\nexport const useMesh = <Node, ElementType extends Element>({\n    elementRef,\n    nodes,\n    getNodePosition,\n    width,\n    height,\n    margin = defaultMargin,\n    isInteractive = true,\n    detectionRadius = Infinity,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    tooltip,\n    tooltipPosition = defaultTooltipPosition,\n    tooltipAnchor = defaultTooltipAnchor,\n    debug = false,\n}: {\n    elementRef: MutableRefObject<ElementType | null>\n    nodes: readonly Node[]\n    getNodePosition?: NodePositionAccessor<Node>\n    width: number\n    height: number\n    margin?: Margin\n    isInteractive?: boolean\n    detectionRadius?: number\n    setCurrent?: (node: Node | null) => void\n    onMouseEnter?: NodeMouseHandler<Node>\n    onMouseMove?: NodeMouseHandler<Node>\n    onMouseLeave?: NodeMouseHandler<Node>\n    onClick?: NodeMouseHandler<Node>\n    tooltip?: (node: Node) => JSX.Element\n    tooltipPosition?: TooltipPosition\n    tooltipAnchor?: TooltipAnchor\n    debug?: boolean\n}) => {\n    const { delaunay, voronoi } = useVoronoiMesh<Node>({\n        points: nodes,\n        getNodePosition,\n        width,\n        height,\n        margin,\n        debug,\n    })\n\n    const { handleMouseEnter, handleMouseMove, handleMouseLeave, handleClick, current } =\n        useMeshEvents<Node, ElementType>({\n            elementRef,\n            nodes,\n            margin,\n            setCurrent,\n            delaunay,\n            detectionRadius,\n            isInteractive,\n            onMouseEnter,\n            onMouseMove,\n            onMouseLeave,\n            onClick,\n            tooltip,\n            tooltipPosition,\n            tooltipAnchor,\n        })\n\n    return {\n        delaunay,\n        voronoi,\n        current,\n        handleMouseEnter,\n        handleMouseMove,\n        handleMouseLeave,\n        handleClick,\n    }\n}\n","import { createElement, Fragment, ReactNode } from 'react'\nimport { Container, SvgWrapper, useDimensions } from '@nivo/core'\nimport { VoronoiSvgProps, VoronoiLayerId } from './types'\nimport { defaultVoronoiProps } from './props'\nimport { useVoronoi, useVoronoiLayerContext } from './hooks'\n\ntype InnerVoronoiProps = Partial<Omit<VoronoiSvgProps, 'data' | 'width' | 'height'>> &\n    Pick<VoronoiSvgProps, 'data' | 'width' | 'height'>\n\nconst InnerVoronoi = ({\n    data,\n    width,\n    height,\n    margin: partialMargin,\n    layers = defaultVoronoiProps.layers,\n    xDomain = defaultVoronoiProps.xDomain,\n    yDomain = defaultVoronoiProps.yDomain,\n    enableLinks = defaultVoronoiProps.enableLinks,\n    linkLineWidth = defaultVoronoiProps.linkLineWidth,\n    linkLineColor = defaultVoronoiProps.linkLineColor,\n    enableCells = defaultVoronoiProps.enableCells,\n    cellLineWidth = defaultVoronoiProps.cellLineWidth,\n    cellLineColor = defaultVoronoiProps.cellLineColor,\n    enablePoints = defaultVoronoiProps.enableCells,\n    pointSize = defaultVoronoiProps.pointSize,\n    pointColor = defaultVoronoiProps.pointColor,\n    role = defaultVoronoiProps.role,\n}: InnerVoronoiProps) => {\n    const { outerWidth, outerHeight, margin, innerWidth, innerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const { points, delaunay, voronoi } = useVoronoi({\n        data,\n        width: innerWidth,\n        height: innerHeight,\n        xDomain,\n        yDomain,\n    })\n\n    const layerById: Record<VoronoiLayerId, ReactNode> = {\n        links: null,\n        cells: null,\n        points: null,\n        bounds: null,\n    }\n\n    if (enableLinks && layers.includes('links')) {\n        layerById.links = (\n            <path\n                key=\"links\"\n                stroke={linkLineColor}\n                strokeWidth={linkLineWidth}\n                fill=\"none\"\n                d={delaunay.render()}\n            />\n        )\n    }\n\n    if (enableCells && layers.includes('cells')) {\n        layerById.cells = (\n            <path\n                key=\"cells\"\n                d={voronoi.render()}\n                fill=\"none\"\n                stroke={cellLineColor}\n                strokeWidth={cellLineWidth}\n            />\n        )\n    }\n\n    if (enablePoints && layers.includes('points')) {\n        layerById.points = (\n            <path\n                key=\"points\"\n                stroke=\"none\"\n                fill={pointColor}\n                d={delaunay.renderPoints(undefined, pointSize / 2)}\n            />\n        )\n    }\n\n    if (layers.includes('bounds')) {\n        layerById.bounds = (\n            <path\n                key=\"bounds\"\n                fill=\"none\"\n                stroke={cellLineColor}\n                strokeWidth={cellLineWidth}\n                d={voronoi.renderBounds()}\n            />\n        )\n    }\n\n    const layerContext = useVoronoiLayerContext({\n        points,\n        delaunay,\n        voronoi,\n    })\n\n    return (\n        <SvgWrapper width={outerWidth} height={outerHeight} margin={margin} role={role}>\n            {layers.map((layer, i) => {\n                if (layerById[layer as VoronoiLayerId] !== undefined) {\n                    return layerById[layer as VoronoiLayerId]\n                }\n\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{createElement(layer, layerContext)}</Fragment>\n                }\n\n                return null\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport const Voronoi = ({\n    theme,\n    ...otherProps\n}: Partial<Omit<VoronoiSvgProps, 'data' | 'width' | 'height'>> &\n    Pick<VoronoiSvgProps, 'data' | 'width' | 'height'>) => (\n    <Container isInteractive={false} animate={false} theme={theme}>\n        <InnerVoronoi {...otherProps} />\n    </Container>\n)\n","import { ResponsiveWrapper } from '@nivo/core'\nimport { VoronoiSvgProps } from './types'\nimport { Voronoi } from './Voronoi'\n\ntype ResponsiveVoronoiProps = Partial<Omit<VoronoiSvgProps, 'data' | 'width' | 'height'>> &\n    Pick<VoronoiSvgProps, 'data'>\n\nexport const ResponsiveVoronoi = (props: ResponsiveVoronoiProps) => (\n    <ResponsiveWrapper>\n        {({ width, height }: { width: number; height: number }) => (\n            <Voronoi width={width} height={height} {...props} />\n        )}\n    </ResponsiveWrapper>\n)\n","import { useMemo, useRef } from 'react'\nimport { Margin } from '@nivo/core'\nimport { TooltipAnchor, TooltipPosition } from '@nivo/tooltip'\nimport { useVoronoiMesh, useMeshEvents } from './hooks'\nimport { NodeMouseHandler, NodePositionAccessor, NodeTouchHandler } from './types'\nimport { defaultMargin, defaultTooltipAnchor, defaultTooltipPosition } from './defaults'\n\ninterface MeshProps<Node> {\n    nodes: Node[]\n    width: number\n    height: number\n    margin?: Margin\n    getNodePosition?: NodePositionAccessor<Node>\n    // Can be used in case you want to keep track of the current node externally,\n    // the current node being the last hovered node.\n    setCurrent?: (node: Node | null) => void\n    onMouseEnter?: NodeMouseHandler<Node>\n    onMouseMove?: NodeMouseHandler<Node>\n    onMouseLeave?: NodeMouseHandler<Node>\n    onClick?: NodeMouseHandler<Node>\n    onTouchStart?: NodeTouchHandler<Node>\n    onTouchMove?: NodeTouchHandler<Node>\n    onTouchEnd?: NodeTouchHandler<Node>\n    enableTouchCrosshair?: boolean\n    // Restrict the node detection to a given radius, default to `Infinity`.\n    detectionRadius?: number\n    // If specified, tooltips are going to be handled automatically.\n    tooltip?: (node: Node) => JSX.Element\n    tooltipPosition?: TooltipPosition\n    tooltipAnchor?: TooltipAnchor\n    // Display the voronoi mesh for debugging purpose.\n    debug?: boolean\n}\n\nexport const Mesh = <Node,>({\n    nodes,\n    width,\n    height,\n    margin = defaultMargin,\n    getNodePosition,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n    enableTouchCrosshair = false,\n    detectionRadius = Infinity,\n    tooltip,\n    tooltipPosition = defaultTooltipPosition,\n    tooltipAnchor = defaultTooltipAnchor,\n    debug,\n}: MeshProps<Node>) => {\n    const elementRef = useRef<SVGRectElement | null>(null)\n\n    const { delaunay, voronoi } = useVoronoiMesh<Node>({\n        points: nodes,\n        getNodePosition,\n        width,\n        height,\n        margin,\n        debug,\n    })\n\n    const {\n        current,\n        handleMouseEnter,\n        handleMouseMove,\n        handleMouseLeave,\n        handleClick,\n        handleTouchStart,\n        handleTouchMove,\n        handleTouchEnd,\n    } = useMeshEvents<Node, SVGRectElement>({\n        elementRef,\n        nodes,\n        delaunay,\n        margin,\n        detectionRadius,\n        setCurrent,\n        onMouseEnter,\n        onMouseMove,\n        onMouseLeave,\n        onClick,\n        onTouchStart,\n        onTouchMove,\n        onTouchEnd,\n        enableTouchCrosshair,\n        tooltip,\n        tooltipPosition,\n        tooltipAnchor,\n    })\n\n    const voronoiPath = useMemo(() => {\n        if (debug && voronoi) return voronoi.render()\n        return undefined\n    }, [debug, voronoi])\n\n    return (\n        <g ref={elementRef} transform={`translate(${-margin.left},${-margin.top})`}>\n            {debug && voronoi && (\n                <>\n                    <path d={voronoiPath} stroke=\"red\" strokeWidth={1} opacity={0.75} />\n                    {detectionRadius < Infinity && (\n                        <path\n                            stroke=\"red\"\n                            strokeWidth={0.35}\n                            fill=\"none\"\n                            d={delaunay.renderPoints(undefined, detectionRadius)}\n                        />\n                    )}\n                    {/* highlight the current cell */}\n                    {current && (\n                        <path fill=\"pink\" opacity={0.35} d={voronoi.renderCell(current[0])} />\n                    )}\n                </>\n            )}\n            {/* transparent rect to intercept mouse events */}\n            <rect\n                data-ref=\"mesh-interceptor\"\n                width={margin.left + width + margin.right}\n                height={margin.top + height + margin.bottom}\n                fill=\"red\"\n                opacity={0}\n                style={{ cursor: 'auto' }}\n                onMouseEnter={handleMouseEnter}\n                onMouseMove={handleMouseMove}\n                onMouseLeave={handleMouseLeave}\n                onTouchStart={handleTouchStart}\n                onTouchMove={handleTouchMove}\n                onTouchEnd={handleTouchEnd}\n                onClick={handleClick}\n            />\n        </g>\n    )\n}\n","import { Delaunay, Voronoi } from 'd3-delaunay'\n\nexport const renderVoronoiToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    voronoi: Voronoi<Delaunay.Point>\n) => {\n    ctx.save()\n\n    ctx.globalAlpha = 0.75\n    ctx.beginPath()\n    voronoi.render(ctx)\n    ctx.strokeStyle = 'red'\n    ctx.lineWidth = 1\n    ctx.stroke()\n\n    ctx.restore()\n}\n\nexport const renderDelaunayPointsToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    delaunay: Delaunay<Delaunay.Point>,\n    radius: number\n) => {\n    ctx.save()\n\n    ctx.globalAlpha = 0.15\n    ctx.beginPath()\n    delaunay.renderPoints(ctx, radius)\n    ctx.strokeStyle = 'red'\n    ctx.lineWidth = 1\n    ctx.stroke()\n\n    ctx.restore()\n}\n\nexport const renderVoronoiCellToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    voronoi: Voronoi<Delaunay.Point>,\n    index: number\n) => {\n    ctx.save()\n\n    ctx.globalAlpha = 0.35\n    ctx.beginPath()\n    voronoi.renderCell(index, ctx)\n    ctx.fillStyle = 'pink'\n    ctx.fill()\n\n    ctx.restore()\n}\n\nexport const renderDebugToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    {\n        delaunay,\n        voronoi,\n        detectionRadius,\n        index,\n    }: {\n        delaunay: Delaunay<Delaunay.Point>\n        voronoi: Voronoi<Delaunay.Point>\n        detectionRadius: number\n        index: number | null\n    }\n) => {\n    renderVoronoiToCanvas(ctx, voronoi)\n\n    if (detectionRadius < Infinity) {\n        renderDelaunayPointsToCanvas(ctx, delaunay, detectionRadius)\n    }\n\n    if (index !== null) {\n        renderVoronoiCellToCanvas(ctx, voronoi, index)\n    }\n}\n"],"names":["defaultVoronoiProps","xDomain","yDomain","layers","enableLinks","linkLineWidth","linkLineColor","enableCells","cellLineWidth","cellLineColor","enablePoints","pointSize","pointColor","role","defaultNodePositionAccessor","node","x","y","defaultMargin","coreDefaultMargin","defaultTooltipPosition","defaultTooltipAnchor","computeMeshPoints","_ref","points","_ref$getNodePosition","getNodePosition","_ref$margin","margin","map","_getNodePosition","left","top","computeMesh","_ref2","width","height","_ref2$margin","debug","delaunay","Delaunay","from","voronoi","right","bottom","undefined","useVoronoiMesh","useMemo","useVoronoi","data","xScale","scaleLinear","domain","range","yScale","d","p","useVoronoiLayerContext","_ref3","useMeshEvents","_ref4","elementRef","nodes","_ref4$getNodePosition","setCurrentNode","setCurrent","_ref4$margin","_ref4$detectionRadius","detectionRadius","Infinity","_ref4$isInteractive","isInteractive","onMouseEnter","onMouseMove","onMouseLeave","onClick","onTouchStart","onTouchMove","onTouchEnd","_ref4$enableTouchCros","enableTouchCrosshair","tooltip","_ref4$tooltipPosition","tooltipPosition","_ref4$tooltipAnchor","tooltipAnchor","_useState","useState","current","previous","useRef","useEffect","findNode","useCallback","event","_getRelativeCursor","getRelativeCursor","index","find","nodeX","nodeY","getDistance","_useTooltip","useTooltip","showTooltipAt","showTooltipFromEvent","hideTooltip","showTooltip","_getNodePosition2","handleMouseEnter","match","handleMouseMove","_previous$current","previousIndex","previousNode","handleMouseLeave","handleClick","handleTouchStart","handleTouchMove","handleTouchEnd","useMesh","_ref5","_ref5$margin","_ref5$isInteractive","_ref5$detectionRadius","_ref5$tooltipPosition","_ref5$tooltipAnchor","_ref5$debug","_useVoronoiMesh","_useMeshEvents","InnerVoronoi","partialMargin","_ref$layers","_ref$xDomain","_ref$yDomain","_ref$enableLinks","_ref$linkLineWidth","_ref$linkLineColor","_ref$enableCells","_ref$cellLineWidth","_ref$cellLineColor","_ref$enablePoints","_ref$pointSize","_ref$pointColor","_ref$role","_useDimensions","useDimensions","outerWidth","outerHeight","innerWidth","innerHeight","_useVoronoi","layerById","links","cells","bounds","includes","_jsx","stroke","strokeWidth","fill","render","renderPoints","renderBounds","layerContext","SvgWrapper","children","layer","i","Fragment","createElement","Voronoi","theme","otherProps","_objectWithoutPropertiesLoose","_excluded","Container","animate","_extends","ResponsiveVoronoi","props","ResponsiveWrapper","Mesh","_ref$enableTouchCross","_ref$detectionRadius","_ref$tooltipPosition","_ref$tooltipAnchor","voronoiPath","_jsxs","ref","transform","_Fragment","opacity","renderCell","style","cursor","renderVoronoiToCanvas","ctx","save","globalAlpha","beginPath","strokeStyle","lineWidth","restore","renderDelaunayPointsToCanvas","radius","renderVoronoiCellToCanvas","fillStyle","renderDebugToCanvas"],"mappings":"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"}