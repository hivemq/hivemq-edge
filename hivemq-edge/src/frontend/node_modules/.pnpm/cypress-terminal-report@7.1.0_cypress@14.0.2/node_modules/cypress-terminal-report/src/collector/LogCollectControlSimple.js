"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = __importDefault(require("../constants"));
const LogCollectControlBase_1 = __importDefault(require("./LogCollectControlBase"));
const utils_1 = __importDefault(require("../utils"));
/**
 * Collects and dispatches all logs from all tests and hooks.
 */
class LogCollectControlSimple extends LogCollectControlBase_1.default {
    constructor(collectorState, config) {
        super();
        this.collectorState = collectorState;
        this.config = config;
        this.config = config;
        this.collectorState = collectorState;
    }
    register() {
        this.registerState();
        if (this.config.enableContinuousLogging) {
            this.registerTestsContinuous();
        }
        else {
            this.registerTests();
        }
        this.registerLogToFiles();
    }
    triggerSendTask(buildDataMessage, noQueue, wait) {
        if (noQueue) {
            utils_1.default.nonQueueTask(constants_1.default.TASK_NAME, buildDataMessage()).catch(console.error);
        }
        else {
            // Need to wait for command log update debounce.
            cy.wait(wait, { log: false }).then(() => cy.task(constants_1.default.TASK_NAME, buildDataMessage(), { log: false }));
        }
    }
    registerState() {
        Cypress.on('log:changed', (options) => {
            if (options.state === 'failed') {
                this.collectorState.updateLogStatus(options.id);
            }
        });
        Cypress.mocha.getRunner().on('test', (test) => {
            this.collectorState.startTest(test);
        });
        Cypress.mocha.getRunner().on('suite', () => {
            this.collectorState.startSuite();
        });
        Cypress.mocha.getRunner().on('suite end', () => {
            this.collectorState.endSuite();
        });
    }
    registerTests() {
        const self = this;
        afterEach(function () {
            self.sendLogsToPrinter(self.collectorState.getCurrentLogStackIndex(), self.collectorState.getCurrentTest());
        });
        // Logs commands if test was manually skipped.
        Cypress.mocha.getRunner().on('pending', function () {
            let test = self.collectorState.getCurrentTest();
            if ((test === null || test === void 0 ? void 0 : test.state) === 'pending') {
                // In case of fully skipped tests we might not yet have a log stack.
                self.collectorState.ensureLogStack();
                self.sendLogsToPrinter(self.collectorState.getCurrentLogStackIndex(), test, {
                    noQueue: true,
                });
            }
        });
    }
    registerTestsContinuous() {
        const self = this;
        this.collectorState.addEventListener('log', () => {
            self.sendLogsToPrinter(self.collectorState.getCurrentLogStackIndex(), self.collectorState.getCurrentTest(), { noQueue: true, continuous: true });
            this.collectorState.addNewLogStack();
        });
    }
    registerLogToFiles() {
        after(function () {
            cy.task(constants_1.default.TASK_NAME_OUTPUT, null, { log: false });
        });
    }
}
exports.default = LogCollectControlSimple;
