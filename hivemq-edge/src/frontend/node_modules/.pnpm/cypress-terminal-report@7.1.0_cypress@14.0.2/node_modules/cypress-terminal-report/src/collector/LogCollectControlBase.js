"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const CtrError_1 = __importDefault(require("../CtrError"));
class LogCollectControlBase {
    sendLogsToPrinter(logStackIndex, mochaRunnable, options = {}) {
        let testState = options.state || mochaRunnable.state;
        let testTitle = options.title || mochaRunnable.title;
        let testLevel = 0;
        let spec = this.getSpecFilePath(mochaRunnable);
        if (!spec)
            return;
        let wait = typeof options.wait === 'number' ? options.wait : 5;
        {
            let parent = mochaRunnable.parent;
            while (parent === null || parent === void 0 ? void 0 : parent.title) {
                testTitle = `${parent.title} -> ${testTitle}`;
                parent = parent.parent;
                ++testLevel;
            }
        }
        if (testState === 'failed' && mochaRunnable && mochaRunnable['_retries'] > 0) {
            testTitle += ` (Attempt ${mochaRunnable && mochaRunnable['_currentRetry'] + 1})`;
        }
        const prepareLogs = () => this.prepareLogs(logStackIndex, { mochaRunnable, testState, testTitle, testLevel });
        const buildDataMessage = () => ({
            spec: spec,
            test: testTitle,
            messages: prepareLogs(),
            state: testState,
            level: testLevel,
            consoleTitle: options.consoleTitle,
            isHook: options.isHook,
            continuous: options.continuous,
        });
        this.triggerSendTask(buildDataMessage, options.noQueue || false, wait);
    }
    prepareLogs(logStackIndex, testData) {
        let logsCopy = this.collectorState.consumeLogStacks(logStackIndex);
        if (logsCopy === null) {
            throw new CtrError_1.default(`Domain exception: log stack null.`);
        }
        if (this.config.filterLog) {
            logsCopy = logsCopy.filter(this.config.filterLog);
        }
        if (this.config.processLog) {
            logsCopy = logsCopy.map(this.config.processLog);
        }
        if (this.config.collectTestLogs) {
            this.config.collectTestLogs(testData, logsCopy);
        }
        return logsCopy;
    }
    getSpecFilePath(mochaRunnable) {
        var _a, _b, _c, _d;
        if (!mochaRunnable.invocationDetails && !((_a = mochaRunnable.parent) === null || _a === void 0 ? void 0 : _a.invocationDetails)) {
            return (_c = (_b = mochaRunnable.parent) === null || _b === void 0 ? void 0 : _b.file) !== null && _c !== void 0 ? _c : null;
        }
        let invocationDetails = mochaRunnable.invocationDetails;
        let parent = mochaRunnable.parent;
        // always get top-most spec to determine the called .spec file
        while (parent === null || parent === void 0 ? void 0 : parent.invocationDetails) {
            invocationDetails = parent.invocationDetails;
            parent = parent.parent;
        }
        return ((parent === null || parent === void 0 ? void 0 : parent.file) || // Support for cypress-grep.
            invocationDetails.relativeFile ||
            ((_d = invocationDetails.fileUrl) === null || _d === void 0 ? void 0 : _d.replace(/^[^?]+\?p=/, '')));
    }
}
exports.default = LogCollectControlBase;
