import type { ExtendedSupportOptions } from '../installLogsCollector.types';
import type { Log, Severity } from '../types';
type LogArray = [Log['type'], Log['message'], Log['severity']];
interface StackLog extends Log {
    timeString?: string;
    chainId?: string;
}
export type StackLogArray = StackLog[] & {
    _ctr_before_each?: number;
};
export default class LogCollectorState extends EventTarget {
    protected config: ExtendedSupportOptions;
    afterHookIndexes: number[];
    beforeHookIndexes: number[];
    currentTest: Mocha.Runnable;
    isStrict: boolean;
    listeners: Record<string, CallableFunction[]>;
    logStacks: Array<StackLogArray | null>;
    suiteStartTime: Date | null;
    logProcessors: Array<(log: StackLog) => void>;
    constructor(config: ExtendedSupportOptions);
    setStrict(): void;
    addNewLogStack(): void;
    ensureLogStack(): void;
    getCurrentLogStackIndex(): number;
    getCurrentLogStack(): StackLogArray | null;
    consumeLogStacks(index: number): StackLogArray | null;
    hasLogsInCurrentStack(): boolean | null;
    getCurrentTest(): Mocha.Runnable;
    addLog(entry: LogArray, chainId?: string): void;
    updateLog(log: string, severity: Severity, id: string): void;
    updateLogStatus(id: string, state?: Severity): void;
    findReversed(id: string): StackLog | null;
    markCurrentStackFromBeforeEach(): void;
    incrementBeforeHookIndex(): void;
    incrementAfterHookIndex(): void;
    getBeforeHookTestTile(): string;
    getAfterHookTestTile(): string;
    startSuite(): void;
    endSuite(): void;
    startTest(test: Mocha.Test): void;
}
export {};
