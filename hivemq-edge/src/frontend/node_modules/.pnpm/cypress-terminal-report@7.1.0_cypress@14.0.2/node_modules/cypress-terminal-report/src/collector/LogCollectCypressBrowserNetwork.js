"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = __importDefault(require("../constants"));
const LogCollectBase_1 = __importDefault(require("./LogCollectBase"));
class LogCollectCypressBrowserNetwork extends LogCollectBase_1.default {
    constructor(type, collectorState, config) {
        super(collectorState, config);
        this.type = type;
        this.collectorState = collectorState;
        this.config = config;
        this.messageProcessors = [];
        let format = this.format;
        this.typeString =
            type === 'xhr' ? constants_1.default.LOG_TYPES.CYPRESS_XHR : constants_1.default.LOG_TYPES.CYPRESS_FETCH;
        if (this.config.collectRequestData && this.config.collectHeaderData) {
            this.messageProcessors.push(async (props) => props['Request Headers']
                ? `\nRequest headers: ${await format.formatXhrData(props['Request Headers'])}`
                : '');
        }
        if (this.config.collectRequestData && this.config.collectBody) {
            this.messageProcessors.push(async (props) => props['Request Body']
                ? `\nRequest body: ${await format.formatXhrData(props['Request Body'])}`
                : '');
        }
        if (this.config.collectHeaderData) {
            this.messageProcessors.push(async (props) => props['Response Headers']
                ? `\nResponse headers: ${await format.formatXhrData(props['Response Headers'])}`
                : '');
        }
        if (this.config.collectBody) {
            this.messageProcessors.push(async (props, isSuccess) => props['Response Body'] && !isSuccess
                ? `\nResponse body: ${await format.formatXhrData(props['Response Body'])}`
                : '');
        }
    }
    register() {
        // In Cypress 13+ this is under an extra props key
        const getConsoleProps = (options) => { var _a; return ((_a = options.consoleProps) === null || _a === void 0 ? void 0 : _a.props) || options.consoleProps; };
        const formatXhr = (options, props) => (options.alias !== undefined ? '(' + options.alias + ') ' : '') +
            (options.renderProps.wentToOrigin || props['Request went to origin?'] === 'yes'
                ? ''
                : 'STUBBED ') +
            props.Method +
            ' ' +
            props.URL;
        const formatDuration = (durationInMs) => durationInMs < 1000 ? `${durationInMs} ms` : `${durationInMs / 1000} s`;
        Cypress.on('log:added', (options) => {
            const props = getConsoleProps(options);
            if (props && options.instrument === 'command' && options.displayName === this.type) {
                const log = formatXhr(options, props);
                const severity = options.state === 'failed' ? constants_1.default.SEVERITY.WARNING : constants_1.default.SEVERITY.SUCCESS;
                this.collectorState.addLog([this.typeString, log, severity], options.id);
            }
        });
        Cypress.on('log:changed', async (options) => {
            var _a;
            const props = getConsoleProps(options);
            if (props &&
                options.instrument === 'command' &&
                options.displayName === this.type &&
                options.state !== 'pending') {
                let statusCode = props['Response Status Code'];
                const isSuccess = statusCode && (statusCode + '')[0] === '2';
                const severity = isSuccess ? constants_1.default.SEVERITY.SUCCESS : constants_1.default.SEVERITY.WARNING;
                let log = formatXhr(options, props);
                // @TODO: Not supported anymore :(
                if (props.Duration) {
                    log += ` (${formatDuration(props.Duration)})`;
                }
                if (statusCode) {
                    log += `\nStatus: ${statusCode}`;
                }
                if ((_a = options.err) === null || _a === void 0 ? void 0 : _a.message) {
                    if (options.err.message.match(/abort/)) {
                        log += ' - ABORTED';
                    }
                    else {
                        log += ' - ' + options.err.message;
                    }
                }
                await Promise.all(this.messageProcessors.map((proc) => proc(props, isSuccess))).then((results) => {
                    log += results.join('');
                });
                this.collectorState.updateLog(log, severity, options.id);
            }
        });
    }
}
exports.default = LogCollectCypressBrowserNetwork;
