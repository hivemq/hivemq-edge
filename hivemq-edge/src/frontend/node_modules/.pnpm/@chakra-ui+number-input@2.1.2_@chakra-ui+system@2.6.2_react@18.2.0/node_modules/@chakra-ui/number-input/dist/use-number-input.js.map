{"version":3,"sources":["../src/use-number-input.ts","../src/use-attr-observer.ts","../src/use-spinner.ts"],"sourcesContent":["import { useCounter, UseCounterProps } from \"@chakra-ui/counter\"\nimport { useEventListener } from \"@chakra-ui/react-use-event-listener\"\nimport { useUpdateEffect } from \"@chakra-ui/react-use-update-effect\"\nimport { useSafeLayoutEffect } from \"@chakra-ui/react-use-safe-layout-effect\"\nimport { useCallbackRef } from \"@chakra-ui/react-use-callback-ref\"\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\"\nimport { ariaAttr, callAllHandlers } from \"@chakra-ui/shared-utils\"\nimport { InputDOMAttributes, PropGetter } from \"@chakra-ui/react-types\"\nimport { useCallback, useMemo, useRef, useState } from \"react\"\nimport { useAttributeObserver } from \"./use-attr-observer\"\nimport { useSpinner } from \"./use-spinner\"\n\nconst FLOATING_POINT_REGEX = /^[Ee0-9+\\-.]$/\n\n/**\n * Determine if a character is a DOM floating point character\n * @see https://www.w3.org/TR/2012/WD-html-markup-20120329/datatypes.html#common.data.float\n */\nfunction isFloatingPointNumericCharacter(character: string) {\n  return FLOATING_POINT_REGEX.test(character)\n}\n\nfunction isValidNumericKeyboardEvent(\n  event: React.KeyboardEvent,\n  isValid: (key: string) => boolean,\n) {\n  if (event.key == null) return true\n  const isModifierKey = event.ctrlKey || event.altKey || event.metaKey\n  const isSingleCharacterKey = event.key.length === 1\n  if (!isSingleCharacterKey || isModifierKey) return true\n  return isValid(event.key)\n}\n\nexport interface UseNumberInputProps extends UseCounterProps {\n  /**\n   * If `true`, the input will be focused as you increment\n   * or decrement the value with the stepper\n   *\n   * @default true\n   */\n  focusInputOnChange?: boolean\n  /**\n   * This controls the value update when you blur out of the input.\n   * - If `true` and the value is greater than `max`, the value will be reset to `max`\n   * - Else, the value remains the same.\n   *\n   * @default true\n   */\n  clampValueOnBlur?: boolean\n  /**\n   * This is used to format the value so that screen readers\n   * can speak out a more human-friendly value.\n   *\n   * It is used to set the `aria-valuetext` property of the input\n   */\n  getAriaValueText?(value: string | number): string\n  /**\n   * If `true`, the input will be in readonly mode\n   */\n  isReadOnly?: boolean\n  /**\n   * If `true`, the input will have `aria-invalid` set to `true`\n   */\n  isInvalid?: boolean\n  /**\n   * Whether the input should be disabled\n   */\n  isDisabled?: boolean\n  /**\n   * Whether the input is required\n   */\n  isRequired?: boolean\n  /**\n   * The `id` to use for the number input field.\n   */\n  id?: string\n  /**\n   * The pattern used to check the <input> element's value against on form submission.\n   *\n   * @default\n   * \"[0-9]*(.[0-9]+)?\"\n   */\n  pattern?: React.InputHTMLAttributes<any>[\"pattern\"]\n  /**\n   * Hints at the type of data that might be entered by the user. It also determines\n   * the type of keyboard shown to the user on mobile devices\n   *\n   * @default\n   * \"decimal\"\n   */\n  inputMode?: React.InputHTMLAttributes<any>[\"inputMode\"]\n  /**\n   * If `true`, the input's value will change based on mouse wheel\n   */\n  allowMouseWheel?: boolean\n  /**\n   * The HTML `name` attribute used for forms\n   */\n  name?: string\n  \"aria-describedby\"?: string\n  \"aria-label\"?: string\n  \"aria-labelledby\"?: string\n  onFocus?: React.FocusEventHandler<HTMLInputElement>\n  onBlur?: React.FocusEventHandler<HTMLInputElement>\n  onInvalid?: (\n    message: ValidityState,\n    value: string,\n    valueAsNumber: number,\n  ) => void\n  /**\n   * Whether the pressed key should be allowed in the input.\n   * The default behavior is to allow DOM floating point characters defined by /^[Ee0-9+\\-.]$/\n   */\n  isValidCharacter?: (value: string) => boolean\n  /**\n   * If using a custom display format, this converts the custom format to a format `parseFloat` understands.\n   */\n  parse?: (value: string) => string\n  /**\n   * If using a custom display format, this converts the default format to the custom format.\n   */\n  format?: (value: string | number) => string | number\n}\n\ntype ValidityState = \"rangeUnderflow\" | \"rangeOverflow\"\ntype InputSelection = { start: number | null; end: number | null }\n\n/**\n * React hook that implements the WAI-ARIA Spin Button widget\n * and used to create numeric input fields.\n *\n * It returns prop getters you can use to build your own\n * custom number inputs.\n *\n * @see WAI-ARIA https://www.w3.org/WAI/ARIA/apg/patterns/spinbutton/\n * @see Docs     https://www.chakra-ui.com/useNumberInput\n * @see WHATWG   https://html.spec.whatwg.org/multipage/input.html#number-state-(type=number)\n */\nexport function useNumberInput(props: UseNumberInputProps = {}) {\n  const {\n    focusInputOnChange = true,\n    clampValueOnBlur = true,\n    keepWithinRange = true,\n    min = Number.MIN_SAFE_INTEGER,\n    max = Number.MAX_SAFE_INTEGER,\n    step: stepProp = 1,\n    isReadOnly,\n    isDisabled,\n    isRequired,\n    isInvalid,\n    pattern = \"[0-9]*(.[0-9]+)?\",\n    inputMode = \"decimal\",\n    allowMouseWheel,\n    id,\n    onChange: _,\n    precision,\n    name,\n    \"aria-describedby\": ariaDescBy,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    onFocus: onFocusProp,\n    onBlur: onBlurProp,\n    onInvalid: onInvalidProp,\n    getAriaValueText: getAriaValueTextProp,\n    isValidCharacter: isValidCharacterProp,\n    format: formatValue,\n    parse: parseValue,\n    ...htmlProps\n  } = props\n\n  const onFocus = useCallbackRef(onFocusProp)\n  const onBlur = useCallbackRef(onBlurProp)\n  const onInvalid = useCallbackRef(onInvalidProp)\n  const isValidCharacter = useCallbackRef(\n    isValidCharacterProp ?? isFloatingPointNumericCharacter,\n  )\n  const getAriaValueText = useCallbackRef(getAriaValueTextProp)\n\n  /**\n   * Leverage the `useCounter` hook since it provides\n   * the functionality to `increment`, `decrement` and `update`\n   * counter values\n   */\n  const counter = useCounter(props)\n\n  const {\n    update: updateFn,\n    increment: incrementFn,\n    decrement: decrementFn,\n  } = counter\n\n  /**\n   * Keep track of the focused state of the input,\n   * so user can this to change the styles of the\n   * `spinners`, maybe :)\n   */\n  const [isFocused, setFocused] = useState(false)\n  const isInteractive = !(isReadOnly || isDisabled)\n\n  const inputRef = useRef<HTMLInputElement>(null)\n  const inputSelectionRef = useRef<InputSelection | null>(null)\n  const incrementButtonRef = useRef<HTMLButtonElement>(null)\n  const decrementButtonRef = useRef<HTMLButtonElement>(null)\n\n  const sanitize = useCallback(\n    (value: string) => value.split(\"\").filter(isValidCharacter).join(\"\"),\n    [isValidCharacter],\n  )\n\n  const parse = useCallback(\n    (value: string) => parseValue?.(value) ?? value,\n    [parseValue],\n  )\n\n  const format = useCallback(\n    (value: string | number) => (formatValue?.(value) ?? value).toString(),\n    [formatValue],\n  )\n\n  useUpdateEffect(() => {\n    if (counter.valueAsNumber > max) {\n      onInvalid?.(\"rangeOverflow\", format(counter.value), counter.valueAsNumber)\n    } else if (counter.valueAsNumber < min) {\n      onInvalid?.(\"rangeOverflow\", format(counter.value), counter.valueAsNumber)\n    }\n  }, [counter.valueAsNumber, counter.value, format, onInvalid])\n\n  /**\n   * Sync state with uncontrolled form libraries like `react-hook-form`.\n   */\n  useSafeLayoutEffect(() => {\n    if (!inputRef.current) return\n    const notInSync = inputRef.current.value != counter.value\n    if (notInSync) {\n      const parsedInput = parse(inputRef.current.value)\n      counter.setValue(sanitize(parsedInput))\n    }\n  }, [parse, sanitize])\n\n  const increment = useCallback(\n    (step = stepProp) => {\n      if (isInteractive) {\n        incrementFn(step)\n      }\n    },\n    [incrementFn, isInteractive, stepProp],\n  )\n\n  const decrement = useCallback(\n    (step = stepProp) => {\n      if (isInteractive) {\n        decrementFn(step)\n      }\n    },\n    [decrementFn, isInteractive, stepProp],\n  )\n\n  /**\n   * Leverage the `useSpinner` hook to spin the input's value\n   * when long press on the up and down buttons.\n   *\n   * This leverages `setInterval` internally\n   */\n  const spinner = useSpinner(increment, decrement)\n\n  useAttributeObserver(\n    incrementButtonRef,\n    \"disabled\",\n    spinner.stop,\n    spinner.isSpinning,\n  )\n  useAttributeObserver(\n    decrementButtonRef,\n    \"disabled\",\n    spinner.stop,\n    spinner.isSpinning,\n  )\n\n  /**\n   * The `onChange` handler filters out any character typed\n   * that isn't floating point compatible.\n   */\n  const onChange = useCallback(\n    (event: React.ChangeEvent<HTMLInputElement>) => {\n      const evt = event.nativeEvent as InputEvent\n      if (evt.isComposing) return\n      const parsedInput = parse(event.currentTarget.value)\n      updateFn(sanitize(parsedInput))\n      inputSelectionRef.current = {\n        start: event.currentTarget.selectionStart,\n        end: event.currentTarget.selectionEnd,\n      }\n    },\n    [updateFn, sanitize, parse],\n  )\n\n  const _onFocus = useCallback(\n    (event: React.FocusEvent<HTMLInputElement>) => {\n      onFocus?.(event)\n      if (!inputSelectionRef.current) return\n      /**\n       * restore selection if custom format string replacement moved it to the end\n       */\n      event.target.selectionStart =\n        inputSelectionRef.current.start ?? event.currentTarget.value?.length\n      event.currentTarget.selectionEnd =\n        inputSelectionRef.current.end ?? event.currentTarget.selectionStart\n    },\n    [onFocus],\n  )\n\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      if (event.nativeEvent.isComposing) return\n\n      if (!isValidNumericKeyboardEvent(event, isValidCharacter)) {\n        event.preventDefault()\n      }\n\n      /**\n       * Keyboard Accessibility\n       *\n       * We want to increase or decrease the input's value\n       * based on if the user the arrow keys.\n       *\n       * @see https://www.w3.org/TR/wai-aria-practices-1.1/#keyboard-interaction-17\n       */\n      const stepFactor = getStepFactor(event) * stepProp\n\n      const eventKey = event.key\n\n      const keyMap: Record<string, React.KeyboardEventHandler> = {\n        ArrowUp: () => increment(stepFactor),\n        ArrowDown: () => decrement(stepFactor),\n        Home: () => updateFn(min),\n        End: () => updateFn(max),\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        action(event)\n      }\n    },\n    [isValidCharacter, stepProp, increment, decrement, updateFn, min, max],\n  )\n\n  const getStepFactor = <\n    Event extends React.KeyboardEvent | React.WheelEvent | WheelEvent,\n  >(\n    event: Event,\n  ) => {\n    let ratio = 1\n    if (event.metaKey || event.ctrlKey) {\n      ratio = 0.1\n    }\n    if (event.shiftKey) {\n      ratio = 10\n    }\n    return ratio\n  }\n\n  /**\n   * If user would like to use a human-readable representation\n   * of the value, rather than the value itself they can pass `getAriaValueText`\n   *\n   * @see https://www.w3.org/TR/wai-aria-practices-1.1/#wai-aria-roles-states-and-properties-18\n   * @see https://www.w3.org/TR/wai-aria-1.1/#aria-valuetext\n   */\n  const ariaValueText = useMemo(() => {\n    const text = getAriaValueText?.(counter.value)\n    if (text != null) return text\n\n    const defaultText = counter.value.toString()\n    // empty string is an invalid ARIA attribute value\n    return !defaultText ? undefined : defaultText\n  }, [counter.value, getAriaValueText])\n\n  /**\n   * Function that clamps the input's value on blur\n   */\n  const validateAndClamp = useCallback(() => {\n    let next = counter.value as string | number\n    if (counter.value === \"\") return\n\n    const valueStartsWithE = /^[eE]/.test(counter.value.toString())\n\n    if (valueStartsWithE) {\n      counter.setValue(\"\")\n    } else {\n      if (counter.valueAsNumber < min) {\n        next = min\n      }\n      if (counter.valueAsNumber > max) {\n        next = max\n      }\n\n      counter.cast(next)\n    }\n  }, [counter, max, min])\n\n  const onInputBlur = useCallback(() => {\n    setFocused(false)\n\n    if (clampValueOnBlur) {\n      validateAndClamp()\n    }\n  }, [clampValueOnBlur, setFocused, validateAndClamp])\n\n  const focusInput = useCallback(() => {\n    if (focusInputOnChange) {\n      requestAnimationFrame(() => {\n        inputRef.current?.focus()\n      })\n    }\n  }, [focusInputOnChange])\n\n  const spinUp = useCallback(\n    (event: React.PointerEvent) => {\n      event.preventDefault()\n      spinner.up()\n      focusInput()\n    },\n    [focusInput, spinner],\n  )\n\n  const spinDown = useCallback(\n    (event: React.PointerEvent) => {\n      event.preventDefault()\n      spinner.down()\n      focusInput()\n    },\n    [focusInput, spinner],\n  )\n\n  useEventListener(\n    () => inputRef.current,\n    \"wheel\",\n    (event: WheelEvent) => {\n      const doc = inputRef.current?.ownerDocument ?? document\n      const isInputFocused = doc.activeElement === inputRef.current\n      if (!allowMouseWheel || !isInputFocused) return\n\n      event.preventDefault()\n\n      const stepFactor = getStepFactor(event) * stepProp\n      const direction = Math.sign(event.deltaY)\n\n      if (direction === -1) {\n        increment(stepFactor)\n      } else if (direction === 1) {\n        decrement(stepFactor)\n      }\n    },\n    { passive: false },\n  )\n\n  const getIncrementButtonProps: PropGetter = useCallback(\n    (props = {}, ref = null) => {\n      const disabled = isDisabled || (keepWithinRange && counter.isAtMax)\n      return {\n        ...props,\n        ref: mergeRefs(ref, incrementButtonRef),\n        role: \"button\",\n        tabIndex: -1,\n        onPointerDown: callAllHandlers(props.onPointerDown, (event) => {\n          if (event.button !== 0 || disabled) return\n          spinUp(event)\n        }),\n        onPointerLeave: callAllHandlers(props.onPointerLeave, spinner.stop),\n        onPointerUp: callAllHandlers(props.onPointerUp, spinner.stop),\n        disabled,\n        \"aria-disabled\": ariaAttr(disabled),\n      }\n    },\n    [counter.isAtMax, keepWithinRange, spinUp, spinner.stop, isDisabled],\n  )\n\n  const getDecrementButtonProps: PropGetter = useCallback(\n    (props = {}, ref = null) => {\n      const disabled = isDisabled || (keepWithinRange && counter.isAtMin)\n      return {\n        ...props,\n        ref: mergeRefs(ref, decrementButtonRef),\n        role: \"button\",\n        tabIndex: -1,\n        onPointerDown: callAllHandlers(props.onPointerDown, (event) => {\n          if (event.button !== 0 || disabled) return\n          spinDown(event)\n        }),\n        onPointerLeave: callAllHandlers(props.onPointerLeave, spinner.stop),\n        onPointerUp: callAllHandlers(props.onPointerUp, spinner.stop),\n        disabled,\n        \"aria-disabled\": ariaAttr(disabled),\n      }\n    },\n    [counter.isAtMin, keepWithinRange, spinDown, spinner.stop, isDisabled],\n  )\n\n  const getInputProps: PropGetter<InputDOMAttributes, InputDOMAttributes> =\n    useCallback(\n      (props = {}, ref = null) => ({\n        name,\n        inputMode,\n        type: \"text\",\n        pattern,\n        \"aria-labelledby\": ariaLabelledBy,\n        \"aria-label\": ariaLabel,\n        \"aria-describedby\": ariaDescBy,\n        id,\n        disabled: isDisabled,\n        ...props,\n        readOnly: props.readOnly ?? isReadOnly,\n        \"aria-readonly\": props.readOnly ?? isReadOnly,\n        \"aria-required\": props.required ?? isRequired,\n        required: props.required ?? isRequired,\n        ref: mergeRefs(inputRef, ref),\n        value: format(counter.value),\n        role: \"spinbutton\",\n        \"aria-valuemin\": min,\n        \"aria-valuemax\": max,\n        \"aria-valuenow\": Number.isNaN(counter.valueAsNumber)\n          ? undefined\n          : counter.valueAsNumber,\n        \"aria-invalid\": ariaAttr(isInvalid ?? counter.isOutOfRange),\n        \"aria-valuetext\": ariaValueText,\n        autoComplete: \"off\",\n        autoCorrect: \"off\",\n        onChange: callAllHandlers(props.onChange, onChange),\n        onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n        onFocus: callAllHandlers(props.onFocus, _onFocus, () =>\n          setFocused(true),\n        ),\n        onBlur: callAllHandlers(props.onBlur, onBlur, onInputBlur),\n      }),\n      [\n        name,\n        inputMode,\n        pattern,\n        ariaLabelledBy,\n        ariaLabel,\n        format,\n        ariaDescBy,\n        id,\n        isDisabled,\n        isRequired,\n        isReadOnly,\n        isInvalid,\n        counter.value,\n        counter.valueAsNumber,\n        counter.isOutOfRange,\n        min,\n        max,\n        ariaValueText,\n        onChange,\n        onKeyDown,\n        _onFocus,\n        onBlur,\n        onInputBlur,\n      ],\n    )\n\n  return {\n    value: format(counter.value),\n    valueAsNumber: counter.valueAsNumber,\n    isFocused,\n    isDisabled,\n    isReadOnly,\n    getIncrementButtonProps,\n    getDecrementButtonProps,\n    getInputProps,\n    htmlProps,\n  }\n}\n\nexport type UseNumberInputReturn = ReturnType<typeof useNumberInput>\n","import { useEffect } from \"react\"\n\nexport function useAttributeObserver(\n  ref: React.RefObject<HTMLElement | null>,\n  attributes: string | string[],\n  fn: (v: MutationRecord) => void,\n  enabled: boolean,\n) {\n  useEffect(() => {\n    if (!ref.current || !enabled) return\n    const win = ref.current.ownerDocument.defaultView ?? window\n    const attrs = Array.isArray(attributes) ? attributes : [attributes]\n    const obs = new win.MutationObserver((changes) => {\n      for (const change of changes) {\n        if (\n          change.type === \"attributes\" &&\n          change.attributeName &&\n          attrs.includes(change.attributeName)\n        ) {\n          fn(change)\n        }\n      }\n    })\n\n    obs.observe(ref.current, { attributes: true, attributeFilter: attrs })\n\n    return () => obs.disconnect()\n  })\n}\n","import { useInterval } from \"@chakra-ui/react-use-interval\"\nimport { useCallback, useEffect, useRef, useState } from \"react\"\n\n/**\n * When click and hold on a button - the speed of auto changing the value.\n */\nconst CONTINUOUS_CHANGE_INTERVAL = 50\n\n/**\n * When click and hold on a button - the delay before auto changing the value.\n */\nconst CONTINUOUS_CHANGE_DELAY = 300\n\ntype Action = \"increment\" | \"decrement\"\n\n/**\n * React hook used in the number input to spin its\n * value on long press of the spin buttons\n *\n * @param increment the function to increment\n * @param decrement the function to decrement\n */\nexport function useSpinner(increment: Function, decrement: Function) {\n  /**\n   * To keep incrementing/decrementing on press, we call that `spinning`\n   */\n  const [isSpinning, setIsSpinning] = useState(false)\n\n  // This state keeps track of the action (\"increment\" or \"decrement\")\n  const [action, setAction] = useState<Action | null>(null)\n\n  // To increment the value the first time you mousedown, we call that `runOnce`\n  const [runOnce, setRunOnce] = useState(true)\n\n  // Store the timeout instance id in a ref, so we can clear the timeout later\n  const timeoutRef = useRef<any>(null)\n\n  // Clears the timeout from memory\n  const removeTimeout = () => clearTimeout(timeoutRef.current)\n\n  /**\n   * useInterval hook provides a performant way to\n   * update the state value at specific interval\n   */\n  useInterval(\n    () => {\n      if (action === \"increment\") {\n        increment()\n      }\n      if (action === \"decrement\") {\n        decrement()\n      }\n    },\n    isSpinning ? CONTINUOUS_CHANGE_INTERVAL : null,\n  )\n\n  // Function to activate the spinning and increment the value\n  const up = useCallback(() => {\n    // increment the first time\n    if (runOnce) {\n      increment()\n    }\n\n    // after a delay, keep incrementing at interval (\"spinning up\")\n    timeoutRef.current = setTimeout(() => {\n      setRunOnce(false)\n      setIsSpinning(true)\n      setAction(\"increment\")\n    }, CONTINUOUS_CHANGE_DELAY)\n  }, [increment, runOnce])\n\n  // Function to activate the spinning and increment the value\n  const down = useCallback(() => {\n    // decrement the first time\n    if (runOnce) {\n      decrement()\n    }\n\n    // after a delay, keep decrementing at interval (\"spinning down\")\n    timeoutRef.current = setTimeout(() => {\n      setRunOnce(false)\n      setIsSpinning(true)\n      setAction(\"decrement\")\n    }, CONTINUOUS_CHANGE_DELAY)\n  }, [decrement, runOnce])\n\n  // Function to stop spinning (useful for mouseup, keyup handlers)\n  const stop = useCallback(() => {\n    setRunOnce(true)\n    setIsSpinning(false)\n    removeTimeout()\n  }, [])\n\n  /**\n   * If the component unmounts while spinning,\n   * let's clear the timeout as well\n   */\n  useEffect(() => {\n    return () => removeTimeout()\n  }, [])\n\n  return { up, down, stop, isSpinning }\n}\n"],"mappings":"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","names":["import_react","import_react","props"]}