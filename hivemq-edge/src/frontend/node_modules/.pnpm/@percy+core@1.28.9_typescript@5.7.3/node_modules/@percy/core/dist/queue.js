function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldSet(e, t, r) { var s = _classPrivateFieldGet2(t, e); return _classApplyDescriptorSet(e, s, r), r; }
function _classApplyDescriptorSet(e, t, l) { if (t.set) t.set.call(e, l);else { if (!t.writable) throw new TypeError("attempted to set read only private field"); t.value = l; } }
function _classPrivateMethodGet(s, a, r) { return _assertClassBrand(a, s), r; }
function _classPrivateFieldGet(e, t) { var r = _classPrivateFieldGet2(t, e); return _classApplyDescriptorGet(e, r); }
function _classPrivateFieldGet2(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
function _classApplyDescriptorGet(e, t) { return t.get ? t.get.call(e) : t.value; }
import { yieldFor, generatePromise, AbortController } from './utils.js';
import logger from '@percy/logger';

// Assigns a deffered promise and resolve & reject functions to an object
function deferred(obj) {
  return Object.assign(obj, {
    deferred: new Promise((resolve, reject) => {
      Object.assign(obj, {
        resolve,
        reject
      });
    })
  });
}

// Returns the position of a needle within a haystack, or undefined if not found
function positionOf(haystack, needle, i = 1) {
  for (let item of haystack) {
    if (item !== needle) i++;else return i;
  }
}

// Thrown when attempting to push to a closed queue
class QueueClosedError extends Error {
  name = this.constructor.name;
}

// A queue instance keeps a list of arbitrary items to process concurrently,
// configured and controlled by various methods
var _handlers = /*#__PURE__*/new WeakMap();
var _queued = /*#__PURE__*/new WeakMap();
var _pending = /*#__PURE__*/new WeakMap();
var _dequeue = /*#__PURE__*/new WeakSet();
var _find = /*#__PURE__*/new WeakSet();
var _start = /*#__PURE__*/new WeakMap();
var _end = /*#__PURE__*/new WeakMap();
var _process = /*#__PURE__*/new WeakSet();
var _until = /*#__PURE__*/new WeakSet();
export class Queue {
  // item concurrency

  constructor(name) {
    _classPrivateMethodInitSpec(this, _until);
    _classPrivateMethodInitSpec(this, _process);
    _classPrivateMethodInitSpec(this, _find);
    _classPrivateMethodInitSpec(this, _dequeue);
    _defineProperty(this, "concurrency", 10);
    _defineProperty(this, "log", logger('core:queue'));
    _classPrivateFieldInitSpec(this, _handlers, {
      writable: true,
      value: {}
    });
    _classPrivateFieldInitSpec(this, _queued, {
      writable: true,
      value: new Set()
    });
    _classPrivateFieldInitSpec(this, _pending, {
      writable: true,
      value: new Set()
    });
    _classPrivateFieldInitSpec(this, _start, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec(this, _end, {
      writable: true,
      value: null
    });
    _defineProperty(this, "readyState", 0);
    this.name = name;
  }

  // Configure queue properties
  set({
    concurrency
  }) {
    if (concurrency) this.concurrency = concurrency;
    return this;
  }

  // Configure queue handlers

  handle(event, handler) {
    _classPrivateFieldGet(this, _handlers)[event] = handler;
    return this;
  }

  // internal queues

  // Queue size is total queued and pending items
  get size() {
    return _classPrivateFieldGet(this, _queued).size + _classPrivateFieldGet(this, _pending).size;
  }

  // Pushes an item into the queue, additional args are passed to any configured task handler.
  push(item, ...args) {
    let task = deferred({
      item
    });

    // attach any configured error handler
    task.deferred = task.deferred.catch(e => {
      if (!_classPrivateFieldGet(this, _handlers).error) throw e;
      return _classPrivateFieldGet(this, _handlers).error(item, e);
    });

    // when closed, reject with a queue closed error
    if (this.readyState > 2) {
      task.reject(new QueueClosedError());
      return task.deferred;
    }

    // call or set up other handlers
    let exists = this.cancel(item);
    task.ctrl = new AbortController();
    // duplicate abortion controller on task, so it can can be used in further
    // generators and can be cancelled internally
    // TODO fix this for non object item usecase
    if (typeof item === 'object' && !Array.isArray(item) && item !== null) {
      item._ctrl = task.ctrl;
    }
    task.item = item = _classPrivateFieldGet(this, _handlers).push ? _classPrivateFieldGet(this, _handlers).push(item, exists) : item;
    task.handler = () => _classPrivateFieldGet(this, _handlers).task ? _classPrivateFieldGet(this, _handlers).task(item, ...args) : item;

    // queue this task & maybe dequeue the next task
    _classPrivateFieldGet(this, _queued).add(task);
    _classPrivateMethodGet(this, _dequeue, _dequeue2).call(this);

    // return the deferred task promise
    return task.deferred;
  }

  // Maybe processes the next queued item task.

  // Cancels and aborts a specific item task.
  cancel(item) {
    let task = _classPrivateMethodGet(this, _find, _find2).call(this, item);
    task === null || task === void 0 ? void 0 : task.ctrl.abort();
    let queued = _classPrivateFieldGet(this, _queued).delete(task);
    let pending = _classPrivateFieldGet(this, _pending).delete(task);

    // reject queued tasks that are not pending
    if (task && queued && !pending) {
      task.reject(task.ctrl.signal.reason);
    }

    // return the cancelled item
    return task === null || task === void 0 ? void 0 : task.item;
  }

  // Returns an item task matching the provided subject.

  // keep track of start and end tasks

  // Initialize a starting task or return an existing one.
  start() {
    var _classPrivateFieldGet3;
    _classPrivateFieldGet(this, _start) ?? _classPrivateFieldSet(this, _start, deferred({
      readyState: 1
    }));
    (_classPrivateFieldGet3 = _classPrivateFieldGet(this, _start)).handler ?? (_classPrivateFieldGet3.handler = _classPrivateFieldGet(this, _end) // wait for any ending task to complete first
    ? () => _classPrivateFieldGet(this, _end).promise.then(_classPrivateFieldGet(this, _handlers).start) : _classPrivateFieldGet(this, _handlers).start);
    return _classPrivateMethodGet(this, _process, _process2).call(this, _classPrivateFieldGet(this, _start)).deferred;
  }

  // intialize an ending task or return an existing one
  end() {
    var _classPrivateFieldGet4;
    _classPrivateFieldGet(this, _end) ?? _classPrivateFieldSet(this, _end, deferred({
      readyState: 0
    }));
    (_classPrivateFieldGet4 = _classPrivateFieldGet(this, _end)).handler ?? (_classPrivateFieldGet4.handler = _classPrivateFieldGet(this, _start) // wait for any starting task to complete first
    ? () => _classPrivateFieldGet(this, _start).promise.then(_classPrivateFieldGet(this, _handlers).end) : _classPrivateFieldGet(this, _handlers).end);
    return _classPrivateMethodGet(this, _process, _process2).call(this, _classPrivateFieldGet(this, _end)).deferred;
  }

  // represents various queue states such as ready, running, or closed

  // run the queue, starting it if necessary, and start dequeuing tasks
  run() {
    if (!_classPrivateFieldGet(this, _start)) this.start();
    // when starting, state is updated afterwards
    if (this.readyState === 0) _classPrivateFieldGet(this, _start).readyState = 2;
    if (this.readyState === 1) this.readyState = 2;
    while (_classPrivateMethodGet(this, _dequeue, _dequeue2).call(this)) _classPrivateMethodGet(this, _dequeue, _dequeue2).call(this);
    return this;
  }

  // stop a running queue
  stop() {
    if (this.readyState === 2) this.readyState = 1;
    return this;
  }

  // close a running queue, optionally aborting it
  close(abort) {
    var _classPrivateFieldGet5;
    // when starting, state is updated afterwards
    if ((_classPrivateFieldGet5 = _classPrivateFieldGet(this, _start)) !== null && _classPrivateFieldGet5 !== void 0 && _classPrivateFieldGet5.pending) _classPrivateFieldGet(this, _start).readyState = 3;
    if (this.readyState < 3) this.readyState = 3;
    if (abort) this.clear();
    return this;
  }

  // clear and abort any queued tasks
  clear() {
    let tasks = [..._classPrivateFieldGet(this, _queued)];
    this.log.debug(`Clearing ${this.name} queue, queued state: ${_classPrivateFieldGet(this, _queued).size}, pending state: ${_classPrivateFieldGet(this, _pending).size}`);
    _classPrivateFieldGet(this, _queued).clear();
    for (let task of tasks) {
      task.ctrl.abort();
      task.reject(task.ctrl.signal.reason);
    }
  }

  // process a single item task when started
  process(item) {
    var _classPrivateFieldGet6;
    let task = _classPrivateMethodGet(this, _find, _find2).call(this, item);
    if (task && !_classPrivateFieldGet(this, _start)) this.start();
    (_classPrivateFieldGet6 = _classPrivateFieldGet(this, _start)) === null || _classPrivateFieldGet6 === void 0 ? void 0 : _classPrivateFieldGet6.promise.then(() => _classPrivateMethodGet(this, _process, _process2).call(this, task));
    return task === null || task === void 0 ? void 0 : task.deferred;
  }

  // processes tasks using a generator promise, allowing task handlers to be cancelable

  // returns a generator that yeilds until started and no longer pending, calling the
  // callback every 10ms during checks with the current number of pending tasks
  idle(callback) {
    return yieldFor(() => {
      var _classPrivateFieldGet7;
      callback === null || callback === void 0 ? void 0 : callback(_classPrivateFieldGet(this, _pending).size);
      let starting = ((_classPrivateFieldGet7 = _classPrivateFieldGet(this, _start)) === null || _classPrivateFieldGet7 === void 0 ? void 0 : _classPrivateFieldGet7.pending) === true;
      return !starting && !_classPrivateFieldGet(this, _pending).size;
    }, {
      idle: 10
    });
  }

  // process items up to the latest queued item, starting the queue if necessary;
  // returns a generator that yields until the flushed item has finished processing
  flush(callback) {
    this.log.debug(`Flushing ${this.name} queue, queued state: ${_classPrivateFieldGet(this, _queued).size}, pending state: ${_classPrivateFieldGet(this, _pending).size}`);
    let interrupt =
    // check for existing interrupts
    [..._classPrivateFieldGet(this, _pending)].find(t => t.stop) ?? [..._classPrivateFieldGet(this, _queued)].find(t => t.stop);

    // get the latest queued or pending task to track
    let flush = [..._classPrivateFieldGet(this, _queued)].pop() ?? [..._classPrivateFieldGet(this, _pending)].pop();
    // determine if the queue should be stopped after flushing
    if (flush) flush.stop = (interrupt === null || interrupt === void 0 ? void 0 : interrupt.stop) ?? this.readyState < 2;
    // remove the old interrupt to avoid stopping early
    if (interrupt) delete interrupt.stop;
    // start the queue if not started
    if (!_classPrivateFieldGet(this, _start)) this.start();
    // run the queue if stopped
    if (flush !== null && flush !== void 0 && flush.stop) this.run();

    // will yield with the callback until done flushing
    return _classPrivateMethodGet(this, _until, _until2).call(this, flush, callback);
  }

  // Repeatedly yields, calling the callback with the position of the task within the queue
}
function _dequeue2() {
  if (!_classPrivateFieldGet(this, _queued).size || this.readyState < 2) return;
  if (_classPrivateFieldGet(this, _pending).size >= this.concurrency) return;
  let [task] = _classPrivateFieldGet(this, _queued);
  return _classPrivateMethodGet(this, _process, _process2).call(this, task);
}
function _find2(subject) {
  let find = _classPrivateFieldGet(this, _handlers).find
  // use any configured find handler to match items
  ? ({
    item
  }) => _classPrivateFieldGet(this, _handlers).find(subject, item) : ({
    item
  }) => subject === item;
  return (
    // look at queued then pending items
    [..._classPrivateFieldGet(this, _queued)].find(find) ?? [..._classPrivateFieldGet(this, _pending)].find(find)
  );
}
function _process2(task) {
  var _task$ctrl;
  if (!task || task.promise) return task;
  let queued = _classPrivateFieldGet(this, _queued).has(task);
  // remove queued tasks from the queue
  if (queued) _classPrivateFieldGet(this, _queued).delete(task);
  // clear queued tasks when ending
  if (task === _classPrivateFieldGet(this, _end)) this.clear();
  // add queued tasks to pending queue
  if (queued) _classPrivateFieldGet(this, _pending).add(task);
  // stop the queue when necessary
  if (task.stop) this.stop();
  // mark task as pending
  task.pending = true;

  // handle the task using a generator promise
  task.promise = generatePromise(task.handler, (_task$ctrl = task.ctrl) === null || _task$ctrl === void 0 ? void 0 : _task$ctrl.signal, (err, val) => {
    // clean up pending tasks that have not been aborted
    if (queued && !task.ctrl.signal.aborted) _classPrivateFieldGet(this, _pending).delete(task);
    // update queue state when necessary
    if (task.readyState != null) this.readyState = task.readyState;
    // clean up internal tasks after ending
    if (!this.readyState) _classPrivateFieldSet(this, _start, _classPrivateFieldSet(this, _end, null));
    // resolve or reject the deferred task promise
    task[err ? 'reject' : 'resolve'](err ?? val);
    // keep dequeuing when running
    if (this.readyState === 2) this.run();
    // mark pending task done
    task.pending = false;
  });
  return task;
}
async function* _until2(task, callback) {
  try {
    yield* yieldFor(() => {
      var _classPrivateFieldGet8;
      if ((_classPrivateFieldGet8 = _classPrivateFieldGet(this, _start)) !== null && _classPrivateFieldGet8 !== void 0 && _classPrivateFieldGet8.pending) return false;
      let queued,
        pending = _classPrivateFieldGet(this, _pending).size;
      // calculate the position within queued when not pending
      if (task && task.pending == null) queued = positionOf(_classPrivateFieldGet(this, _queued), task);
      // call the callback and return true when not queued or pending
      let position = (queued ?? 0) + pending;
      callback === null || callback === void 0 ? void 0 : callback(position);
      return !position;
    }, {
      idle: 10
    });
  } catch (err) {
    // reset flushed tasks on error
    if (task.stop) this.stop();
    delete task.stop;
    throw err;
  }
}
export default Queue;