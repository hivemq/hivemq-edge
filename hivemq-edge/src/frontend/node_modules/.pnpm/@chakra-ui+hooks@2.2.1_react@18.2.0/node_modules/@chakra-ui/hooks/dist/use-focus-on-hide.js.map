{"version":3,"sources":["../src/use-focus-on-hide.ts","../src/use-update-effect.ts"],"sourcesContent":["import {\n  contains,\n  focus,\n  FocusableElement,\n  getActiveElement,\n  isTabbable,\n} from \"@chakra-ui/utils\"\nimport { RefObject } from \"react\"\nimport { useUpdateEffect } from \"./use-update-effect\"\n\nexport interface UseFocusOnHideOptions {\n  focusRef: RefObject<FocusableElement>\n  shouldFocus?: boolean\n  visible?: boolean\n}\n\nfunction preventReturnFocus(containerRef: React.RefObject<HTMLElement>) {\n  const el = containerRef.current\n  if (!el) return false\n\n  const activeElement = getActiveElement(el)\n\n  if (!activeElement) return false\n  if (contains(el, activeElement)) return false\n  if (isTabbable(activeElement)) return true\n\n  return false\n}\n\n/**\n * Popover hook to manage the focus when the popover closes or hides.\n *\n * We either want to return focus back to the popover trigger or\n * let focus proceed normally if user moved to another interactive\n * element in the viewport.\n */\nexport function useFocusOnHide(\n  containerRef: RefObject<HTMLElement>,\n  options: UseFocusOnHideOptions,\n) {\n  const { shouldFocus: shouldFocusProp, visible, focusRef } = options\n\n  const shouldFocus = shouldFocusProp && !visible\n\n  useUpdateEffect(() => {\n    if (!shouldFocus) return\n\n    if (preventReturnFocus(containerRef)) {\n      return\n    }\n\n    const el = focusRef?.current || containerRef.current\n\n    if (el) {\n      focus(el, { nextTick: true })\n    }\n  }, [shouldFocus, containerRef, focusRef])\n}\n","import { useEffect, useRef } from \"react\"\n\n/**\n * React effect hook that invokes only on update.\n * It doesn't invoke on mount\n */\nexport const useUpdateEffect: typeof useEffect = (effect, deps) => {\n  const renderCycleRef = useRef(false)\n  const effectCycleRef = useRef(false)\n\n  useEffect(() => {\n    const isMounted = renderCycleRef.current\n    const shouldRun = isMounted && effectCycleRef.current\n    if (shouldRun) {\n      return effect()\n    }\n    effectCycleRef.current = true\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps)\n\n  useEffect(() => {\n    renderCycleRef.current = true\n    return () => {\n      renderCycleRef.current = false\n    }\n  }, [])\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAMO;;;ACNP,mBAAkC;AAM3B,IAAM,kBAAoC,CAAC,QAAQ,SAAS;AACjE,QAAM,qBAAiB,qBAAO,KAAK;AACnC,QAAM,qBAAiB,qBAAO,KAAK;AAEnC,8BAAU,MAAM;AACd,UAAM,YAAY,eAAe;AACjC,UAAM,YAAY,aAAa,eAAe;AAC9C,QAAI,WAAW;AACb,aAAO,OAAO;AAAA,IAChB;AACA,mBAAe,UAAU;AAAA,EAE3B,GAAG,IAAI;AAEP,8BAAU,MAAM;AACd,mBAAe,UAAU;AACzB,WAAO,MAAM;AACX,qBAAe,UAAU;AAAA,IAC3B;AAAA,EACF,GAAG,CAAC,CAAC;AACP;;;ADVA,SAAS,mBAAmB,cAA4C;AACtE,QAAM,KAAK,aAAa;AACxB,MAAI,CAAC;AAAI,WAAO;AAEhB,QAAM,oBAAgB,+BAAiB,EAAE;AAEzC,MAAI,CAAC;AAAe,WAAO;AAC3B,UAAI,uBAAS,IAAI,aAAa;AAAG,WAAO;AACxC,UAAI,yBAAW,aAAa;AAAG,WAAO;AAEtC,SAAO;AACT;AASO,SAAS,eACd,cACA,SACA;AACA,QAAM,EAAE,aAAa,iBAAiB,SAAS,SAAS,IAAI;AAE5D,QAAM,cAAc,mBAAmB,CAAC;AAExC,kBAAgB,MAAM;AACpB,QAAI,CAAC;AAAa;AAElB,QAAI,mBAAmB,YAAY,GAAG;AACpC;AAAA,IACF;AAEA,UAAM,MAAK,qCAAU,YAAW,aAAa;AAE7C,QAAI,IAAI;AACN,8BAAM,IAAI,EAAE,UAAU,KAAK,CAAC;AAAA,IAC9B;AAAA,EACF,GAAG,CAAC,aAAa,cAAc,QAAQ,CAAC;AAC1C;","names":[]}