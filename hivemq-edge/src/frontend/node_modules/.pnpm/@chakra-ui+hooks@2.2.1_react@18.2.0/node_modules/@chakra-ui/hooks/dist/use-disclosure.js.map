{"version":3,"sources":["../src/use-disclosure.ts","../src/use-controllable.ts","../src/use-callback-ref.ts","../src/use-safe-layout-effect.ts","../src/use-id.ts"],"sourcesContent":["import { callAllHandlers } from \"@chakra-ui/utils\"\nimport { useControllableProp } from \"./use-controllable\"\nimport { useId } from \"./use-id\"\nimport { useCallbackRef } from \"./use-callback-ref\"\nimport { useCallback, useState } from \"react\"\n\nexport interface UseDisclosureProps {\n  isOpen?: boolean\n  defaultIsOpen?: boolean\n  onClose?(): void\n  onOpen?(): void\n  id?: string\n}\n\nexport function useDisclosure(props: UseDisclosureProps = {}) {\n  const {\n    onClose: onCloseProp,\n    onOpen: onOpenProp,\n    isOpen: isOpenProp,\n    id: idProp,\n  } = props\n\n  const onOpenPropCallbackRef = useCallbackRef(onOpenProp)\n  const onClosePropCallbackRef = useCallbackRef(onCloseProp)\n  const [isOpenState, setIsOpen] = useState(props.defaultIsOpen || false)\n  const [isControlled, isOpen] = useControllableProp(isOpenProp, isOpenState)\n\n  const id = useId(idProp, \"disclosure\")\n\n  const onClose = useCallback(() => {\n    if (!isControlled) {\n      setIsOpen(false)\n    }\n    onClosePropCallbackRef?.()\n  }, [isControlled, onClosePropCallbackRef])\n\n  const onOpen = useCallback(() => {\n    if (!isControlled) {\n      setIsOpen(true)\n    }\n    onOpenPropCallbackRef?.()\n  }, [isControlled, onOpenPropCallbackRef])\n\n  const onToggle = useCallback(() => {\n    const action = isOpen ? onClose : onOpen\n    action()\n  }, [isOpen, onOpen, onClose])\n\n  return {\n    isOpen: !!isOpen,\n    onOpen,\n    onClose,\n    onToggle,\n    isControlled,\n    getButtonProps: (props: any = {}) => ({\n      ...props,\n      \"aria-expanded\": isOpen,\n      \"aria-controls\": id,\n      onClick: callAllHandlers(props.onClick, onToggle),\n    }),\n    getDisclosureProps: (props: any = {}) => ({\n      ...props,\n      hidden: !isOpen,\n      id,\n    }),\n  }\n}\n\nexport type UseDisclosureReturn = ReturnType<typeof useDisclosure>\n","import { runIfFn } from \"@chakra-ui/utils\"\nimport { useCallback, useState } from \"react\"\nimport { useCallbackRef } from \"./use-callback-ref\"\n\nexport function useControllableProp<T>(prop: T | undefined, state: T) {\n  const isControlled = prop !== undefined\n  const value = isControlled && typeof prop !== \"undefined\" ? prop : state\n  return [isControlled, value] as const\n}\n\nexport interface UseControllableStateProps<T> {\n  /**\n   * The value to used in controlled mode\n   */\n  value?: T\n  /**\n   * The initial value to be used, in uncontrolled mode\n   */\n  defaultValue?: T | (() => T)\n  /**\n   * The callback fired when the value changes\n   */\n  onChange?: (value: T) => void\n  /**\n   * The function that determines if the state should be updated\n   */\n  shouldUpdate?: (prev: T, next: T) => boolean\n}\n\n/**\n * React hook for using controlling component state.\n * @param props\n */\nexport function useControllableState<T>(props: UseControllableStateProps<T>) {\n  const {\n    value: valueProp,\n    defaultValue,\n    onChange,\n    shouldUpdate = (prev, next) => prev !== next,\n  } = props\n  const onChangeProp = useCallbackRef(onChange)\n  const shouldUpdateProp = useCallbackRef(shouldUpdate)\n\n  const [valueState, setValue] = useState(defaultValue as T)\n\n  const isControlled = valueProp !== undefined\n  const value = isControlled ? (valueProp as T) : valueState\n\n  const updateValue = useCallback(\n    (next: React.SetStateAction<T>) => {\n      const nextValue = runIfFn(next, value)\n\n      if (!shouldUpdateProp(value, nextValue)) {\n        return\n      }\n\n      if (!isControlled) {\n        setValue(nextValue)\n      }\n\n      onChangeProp(nextValue)\n    },\n    [isControlled, onChangeProp, value, shouldUpdateProp],\n  )\n\n  return [value, updateValue] as [T, React.Dispatch<React.SetStateAction<T>>]\n}\n","import { useCallback, useRef } from \"react\"\nimport { useSafeLayoutEffect } from \"./use-safe-layout-effect\"\n\n/**\n * React hook to persist any value between renders,\n * but keeps it up-to-date if it changes.\n *\n * @param fn the function to persist\n * @param deps the function dependency list\n */\nexport function useCallbackRef<T extends (...args: any[]) => any>(\n  fn: T | undefined,\n  deps: React.DependencyList = [],\n): T {\n  const ref = useRef(fn)\n\n  useSafeLayoutEffect(() => {\n    ref.current = fn\n  })\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return useCallback(((...args) => ref.current?.(...args)) as T, deps)\n}\n","import { isBrowser } from \"@chakra-ui/utils\"\nimport { useEffect, useLayoutEffect } from \"react\"\n\nexport const useSafeLayoutEffect = isBrowser ? useLayoutEffect : useEffect\n","import { useCallback, useId as useReactId, useMemo, useState } from \"react\"\n\nexport function useId(idProp?: string, prefix?: string): string {\n  const id = useReactId()\n\n  return useMemo(\n    () => idProp || [prefix, id].filter(Boolean).join(\"-\"),\n    [idProp, prefix, id],\n  )\n}\n\n/**\n * React hook to generate ids for use in compound components\n *\n * @param idProp the external id passed from the user\n * @param prefixes array of prefixes to use\n *\n * @example\n *\n * ```js\n * const [buttonId, menuId] = useIds(\"52\", \"button\", \"menu\")\n *\n * // buttonId will be `button-52`\n * // menuId will be `menu-52`\n * ```\n */\nexport function useIds(idProp?: string, ...prefixes: string[]) {\n  const id = useId(idProp)\n  return useMemo(() => {\n    return prefixes.map((prefix) => `${prefix}-${id}`)\n  }, [id, prefixes])\n}\n\n/**\n * Used to generate an id, and after render, check if that id is rendered, so we know\n * if we can use it in places such as `aria-labelledby`.\n *\n * @param partId - The unique id for the component part\n *\n * @example\n * const { ref, id } = useOptionalPart<HTMLInputElement>(`${id}-label`)\n */\nexport function useOptionalPart<T = any>(partId: string) {\n  const [id, setId] = useState<string | null>(null)\n  const ref = useCallback(\n    (node: T) => {\n      setId(node ? partId : null)\n    },\n    [partId],\n  )\n  return { ref, id, isRendered: Boolean(id) }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAA,gBAAgC;;;ACAhC,IAAAC,gBAAwB;AACxB,IAAAC,gBAAsC;;;ACDtC,IAAAC,gBAAoC;;;ACApC,mBAA0B;AAC1B,mBAA2C;AAEpC,IAAM,sBAAsB,yBAAY,+BAAkB;;;ADO1D,SAAS,eACd,IACA,OAA6B,CAAC,GAC3B;AACH,QAAM,UAAM,sBAAO,EAAE;AAErB,sBAAoB,MAAM;AACxB,QAAI,UAAU;AAAA,EAChB,CAAC;AAGD,aAAO,2BAAa,IAAI,SAAM;AArBhC;AAqBmC,qBAAI,YAAJ,6BAAc,GAAG;AAAA,KAAa,IAAI;AACrE;;;ADlBO,SAAS,oBAAuB,MAAqB,OAAU;AACpE,QAAM,eAAe,SAAS;AAC9B,QAAM,QAAQ,gBAAgB,OAAO,SAAS,cAAc,OAAO;AACnE,SAAO,CAAC,cAAc,KAAK;AAC7B;;;AGRA,IAAAC,gBAAoE;AAE7D,SAAS,MAAM,QAAiB,QAAyB;AAC9D,QAAM,SAAK,cAAAC,OAAW;AAEtB,aAAO;AAAA,IACL,MAAM,UAAU,CAAC,QAAQ,EAAE,EAAE,OAAO,OAAO,EAAE,KAAK,GAAG;AAAA,IACrD,CAAC,QAAQ,QAAQ,EAAE;AAAA,EACrB;AACF;;;AJLA,IAAAC,gBAAsC;AAU/B,SAAS,cAAc,QAA4B,CAAC,GAAG;AAC5D,QAAM;AAAA,IACJ,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,IAAI;AAAA,EACN,IAAI;AAEJ,QAAM,wBAAwB,eAAe,UAAU;AACvD,QAAM,yBAAyB,eAAe,WAAW;AACzD,QAAM,CAAC,aAAa,SAAS,QAAI,wBAAS,MAAM,iBAAiB,KAAK;AACtE,QAAM,CAAC,cAAc,MAAM,IAAI,oBAAoB,YAAY,WAAW;AAE1E,QAAM,KAAK,MAAM,QAAQ,YAAY;AAErC,QAAM,cAAU,2BAAY,MAAM;AAChC,QAAI,CAAC,cAAc;AACjB,gBAAU,KAAK;AAAA,IACjB;AACA;AAAA,EACF,GAAG,CAAC,cAAc,sBAAsB,CAAC;AAEzC,QAAM,aAAS,2BAAY,MAAM;AAC/B,QAAI,CAAC,cAAc;AACjB,gBAAU,IAAI;AAAA,IAChB;AACA;AAAA,EACF,GAAG,CAAC,cAAc,qBAAqB,CAAC;AAExC,QAAM,eAAW,2BAAY,MAAM;AACjC,UAAM,SAAS,SAAS,UAAU;AAClC,WAAO;AAAA,EACT,GAAG,CAAC,QAAQ,QAAQ,OAAO,CAAC;AAE5B,SAAO;AAAA,IACL,QAAQ,CAAC,CAAC;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,gBAAgB,CAACC,SAAa,CAAC,OAAO;AAAA,MACpC,GAAGA;AAAA,MACH,iBAAiB;AAAA,MACjB,iBAAiB;AAAA,MACjB,aAAS,+BAAgBA,OAAM,SAAS,QAAQ;AAAA,IAClD;AAAA,IACA,oBAAoB,CAACA,SAAa,CAAC,OAAO;AAAA,MACxC,GAAGA;AAAA,MACH,QAAQ,CAAC;AAAA,MACT;AAAA,IACF;AAAA,EACF;AACF;","names":["import_utils","import_utils","import_react","import_react","import_react","useReactId","import_react","props"]}