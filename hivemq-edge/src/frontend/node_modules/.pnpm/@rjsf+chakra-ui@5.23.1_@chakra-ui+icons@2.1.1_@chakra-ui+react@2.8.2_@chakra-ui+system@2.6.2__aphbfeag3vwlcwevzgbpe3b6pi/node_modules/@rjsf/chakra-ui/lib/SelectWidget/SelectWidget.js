import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useMemo } from 'react';
import { FormControl, FormLabel } from '@chakra-ui/react';
import { ariaDescribedByIds, enumOptionsIndexForValue, enumOptionsValueForIndex, labelValue, } from '@rjsf/utils';
import { getChakra } from '../utils';
import { Select } from 'chakra-react-select';
export default function SelectWidget(props) {
    const { id, options, label, hideLabel, placeholder, multiple, required, disabled, readonly, value, autofocus, onChange, onBlur, onFocus, rawErrors = [], uiSchema, schema, } = props;
    const { enumOptions, enumDisabled, emptyValue } = options;
    const chakraProps = getChakra({ uiSchema });
    const _onMultiChange = (e) => {
        return onChange(enumOptionsValueForIndex(e.map((v) => {
            return v.value;
        }), enumOptions, emptyValue));
    };
    const _onChange = (e) => {
        return onChange(enumOptionsValueForIndex(e.value, enumOptions, emptyValue));
    };
    const _onBlur = ({ target }) => onBlur(id, enumOptionsValueForIndex(target && target.value, enumOptions, emptyValue));
    const _onFocus = ({ target }) => onFocus(id, enumOptionsValueForIndex(target && target.value, enumOptions, emptyValue));
    const showPlaceholderOption = !multiple && schema.default === undefined;
    const { valueLabelMap, displayEnumOptions } = useMemo(() => {
        const valueLabelMap = {};
        let displayEnumOptions = [];
        if (Array.isArray(enumOptions)) {
            displayEnumOptions = enumOptions.map((option, index) => {
                const { value, label } = option;
                valueLabelMap[index] = label || String(value);
                return {
                    label,
                    value: String(index),
                    isDisabled: Array.isArray(enumDisabled) && enumDisabled.indexOf(value) !== -1,
                };
            });
            if (showPlaceholderOption) {
                displayEnumOptions.unshift({ value: '', label: placeholder || '' });
            }
        }
        return { valueLabelMap: valueLabelMap, displayEnumOptions: displayEnumOptions };
    }, [enumDisabled, enumOptions, placeholder, showPlaceholderOption]);
    const isMultiple = typeof multiple !== 'undefined' && multiple !== false && Boolean(enumOptions);
    const selectedIndex = enumOptionsIndexForValue(value, enumOptions, isMultiple);
    const formValue = isMultiple
        ? (selectedIndex || []).map((i) => {
            return {
                label: valueLabelMap[i],
                value: i,
            };
        })
        : {
            label: valueLabelMap[selectedIndex] || '',
            selectedIndex,
        };
    return (_jsxs(FormControl, { mb: 1, ...chakraProps, isDisabled: disabled || readonly, isRequired: required, isReadOnly: readonly, isInvalid: rawErrors && rawErrors.length > 0, children: [labelValue(_jsx(FormLabel, { htmlFor: id, id: `${id}-label`, children: label }), hideLabel || !label), _jsx(Select, { inputId: id, name: id, isMulti: isMultiple, options: displayEnumOptions, placeholder: placeholder, closeMenuOnSelect: !isMultiple, onBlur: _onBlur, onChange: isMultiple ? _onMultiChange : _onChange, onFocus: _onFocus, autoFocus: autofocus, value: formValue, "aria-describedby": ariaDescribedByIds(id) })] }));
}
//# sourceMappingURL=SelectWidget.js.map