(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@rjsf/core'), require('@rjsf/utils'), require('@chakra-ui/react'), require('@chakra-ui/icons'), require('react/jsx-runtime'), require('react'), require('chakra-react-select'), require('@emotion/react'), require('@emotion/cache'), require('@emotion/weak-memoize')) :
  typeof define === 'function' && define.amd ? define(['exports', '@rjsf/core', '@rjsf/utils', '@chakra-ui/react', '@chakra-ui/icons', 'react/jsx-runtime', 'react', 'chakra-react-select', '@emotion/react', '@emotion/cache', '@emotion/weak-memoize'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["@rjsf/chakra-ui"] = {}, global.core, global.utils, global.react$1, global.icons, global.jsxRuntime, global.react, global.chakraReactSelect, global.react$2, global.createCache, global.weakMemoize));
})(this, (function (exports, core, utils, react$1, icons, jsxRuntime, react, chakraReactSelect, react$2, createCache, weakMemoize) { 'use strict';

  // src/Form/Form.tsx
  function AddButton({
    uiSchema,
    registry,
    ...props
  }) {
    const { translateString } = registry;
    return /* @__PURE__ */ jsxRuntime.jsx(react$1.Button, { leftIcon: /* @__PURE__ */ jsxRuntime.jsx(icons.AddIcon, {}), ...props, children: translateString(utils.TranslatableString.AddItemButton) });
  }
  function ArrayFieldItemTemplate(props) {
    const {
      children,
      disabled,
      hasToolbar,
      hasCopy,
      hasMoveDown,
      hasMoveUp,
      hasRemove,
      index,
      onCopyIndexClick,
      onDropIndexClick,
      onReorderClick,
      readonly,
      uiSchema,
      registry
    } = props;
    const { CopyButton: CopyButton2, MoveDownButton: MoveDownButton2, MoveUpButton: MoveUpButton2, RemoveButton: RemoveButton2 } = registry.templates.ButtonTemplates;
    const onCopyClick = react.useMemo(() => onCopyIndexClick(index), [index, onCopyIndexClick]);
    const onRemoveClick = react.useMemo(() => onDropIndexClick(index), [index, onDropIndexClick]);
    const onArrowUpClick = react.useMemo(() => onReorderClick(index, index - 1), [index, onReorderClick]);
    const onArrowDownClick = react.useMemo(() => onReorderClick(index, index + 1), [index, onReorderClick]);
    return /* @__PURE__ */ jsxRuntime.jsxs(react$1.HStack, { alignItems: "flex-end", py: 1, children: [
      /* @__PURE__ */ jsxRuntime.jsx(react$1.Box, { w: "100%", children }),
      hasToolbar && /* @__PURE__ */ jsxRuntime.jsx(react$1.Box, { children: /* @__PURE__ */ jsxRuntime.jsxs(react$1.ButtonGroup, { isAttached: true, mb: 1, children: [
        (hasMoveUp || hasMoveDown) && /* @__PURE__ */ jsxRuntime.jsx(
          MoveUpButton2,
          {
            disabled: disabled || readonly || !hasMoveUp,
            onClick: onArrowUpClick,
            uiSchema,
            registry
          }
        ),
        (hasMoveUp || hasMoveDown) && /* @__PURE__ */ jsxRuntime.jsx(
          MoveDownButton2,
          {
            disabled: disabled || readonly || !hasMoveDown,
            onClick: onArrowDownClick,
            uiSchema,
            registry
          }
        ),
        hasCopy && /* @__PURE__ */ jsxRuntime.jsx(
          CopyButton2,
          {
            disabled: disabled || readonly,
            onClick: onCopyClick,
            uiSchema,
            registry
          }
        ),
        hasRemove && /* @__PURE__ */ jsxRuntime.jsx(
          RemoveButton2,
          {
            disabled: disabled || readonly,
            onClick: onRemoveClick,
            uiSchema,
            registry
          }
        )
      ] }) })
    ] });
  }
  function ArrayFieldTemplate(props) {
    const { canAdd, disabled, idSchema, uiSchema, items, onAddClick, readonly, registry, required, schema, title } = props;
    const uiOptions = utils.getUiOptions(uiSchema);
    const ArrayFieldDescriptionTemplate = utils.getTemplate(
      "ArrayFieldDescriptionTemplate",
      registry,
      uiOptions
    );
    const ArrayFieldItemTemplate2 = utils.getTemplate(
      "ArrayFieldItemTemplate",
      registry,
      uiOptions
    );
    const ArrayFieldTitleTemplate = utils.getTemplate(
      "ArrayFieldTitleTemplate",
      registry,
      uiOptions
    );
    const {
      ButtonTemplates: { AddButton: AddButton2 }
    } = registry.templates;
    return /* @__PURE__ */ jsxRuntime.jsxs(react$1.Box, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        ArrayFieldTitleTemplate,
        {
          idSchema,
          title: uiOptions.title || title,
          schema,
          uiSchema,
          required,
          registry
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        ArrayFieldDescriptionTemplate,
        {
          idSchema,
          description: uiOptions.description || schema.description,
          schema,
          uiSchema,
          registry
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsxs(react$1.Grid, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(react$1.GridItem, { children: items.length > 0 && items.map(({ key, ...itemProps }) => /* @__PURE__ */ jsxRuntime.jsx(ArrayFieldItemTemplate2, { ...itemProps }, key)) }),
        canAdd && /* @__PURE__ */ jsxRuntime.jsx(react$1.GridItem, { justifySelf: "flex-end", children: /* @__PURE__ */ jsxRuntime.jsx(react$1.Box, { mt: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
          AddButton2,
          {
            className: "array-item-add",
            onClick: onAddClick,
            disabled: disabled || readonly,
            uiSchema,
            registry
          }
        ) }) })
      ] }, `array-item-list-${idSchema.$id}`)
    ] });
  }
  function getChakra({ uiSchema = {} }) {
    const chakraProps = uiSchema["ui:options"] && uiSchema["ui:options"].chakra || {};
    Object.keys(chakraProps).forEach((key) => {
      if (react$1.shouldForwardProp(key)) {
        delete chakraProps[key];
      }
    });
    return chakraProps;
  }
  function BaseInputTemplate(props) {
    const {
      id,
      type,
      value,
      label,
      hideLabel,
      schema,
      uiSchema,
      onChange,
      onChangeOverride,
      onBlur,
      onFocus,
      options,
      required,
      readonly,
      rawErrors,
      autofocus,
      placeholder,
      disabled
    } = props;
    const inputProps = utils.getInputProps(schema, type, options);
    const chakraProps = getChakra({ uiSchema });
    const _onChange = ({ target: { value: value2 } }) => onChange(value2 === "" ? options.emptyValue : value2);
    const _onBlur = ({ target }) => onBlur(id, target && target.value);
    const _onFocus = ({ target }) => onFocus(id, target && target.value);
    return /* @__PURE__ */ jsxRuntime.jsxs(
      react$1.FormControl,
      {
        mb: 1,
        ...chakraProps,
        isDisabled: disabled || readonly,
        isRequired: required,
        isReadOnly: readonly,
        isInvalid: rawErrors && rawErrors.length > 0,
        children: [
          utils.labelValue(
            /* @__PURE__ */ jsxRuntime.jsx(react$1.FormLabel, { htmlFor: id, id: `${id}-label`, children: label }),
            hideLabel || !label
          ),
          /* @__PURE__ */ jsxRuntime.jsx(
            react$1.Input,
            {
              id,
              name: id,
              value: value || value === 0 ? value : "",
              onChange: onChangeOverride || _onChange,
              onBlur: _onBlur,
              onFocus: _onFocus,
              autoFocus: autofocus,
              placeholder,
              ...inputProps,
              list: schema.examples ? utils.examplesId(id) : void 0,
              "aria-describedby": utils.ariaDescribedByIds(id, !!schema.examples)
            }
          ),
          Array.isArray(schema.examples) ? /* @__PURE__ */ jsxRuntime.jsx("datalist", { id: utils.examplesId(id), children: schema.examples.concat(schema.default && !schema.examples.includes(schema.default) ? [schema.default] : []).map((example) => {
            return /* @__PURE__ */ jsxRuntime.jsx("option", { value: example }, example);
          }) }) : null
        ]
      }
    );
  }
  function DescriptionField({ description, id }) {
    if (!description) {
      return null;
    }
    if (typeof description === "string") {
      return /* @__PURE__ */ jsxRuntime.jsx(react$1.Text, { as: "sup", fontSize: "md", id, children: description });
    }
    return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: description });
  }
  function ErrorList({
    errors,
    registry
  }) {
    const { translateString } = registry;
    return /* @__PURE__ */ jsxRuntime.jsxs(react$1.Alert, { flexDirection: "column", alignItems: "flex-start", gap: 3, status: "error", children: [
      /* @__PURE__ */ jsxRuntime.jsx(react$1.AlertTitle, { children: translateString(utils.TranslatableString.ErrorsLabel) }),
      /* @__PURE__ */ jsxRuntime.jsx(react$1.List, { children: errors.map((error, i) => /* @__PURE__ */ jsxRuntime.jsxs(react$1.ListItem, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(react$1.ListIcon, { as: icons.WarningIcon, color: "red.500" }),
        error.stack
      ] }, i)) })
    ] });
  }
  function ChakraIconButton(props) {
    const { icon, iconType, uiSchema, registry, ...otherProps } = props;
    return /* @__PURE__ */ jsxRuntime.jsx(react$1.IconButton, { "aria-label": props.title, ...otherProps, icon });
  }
  ChakraIconButton.displayName = "ChakraIconButton";
  var ChakraIconButton_default = react.memo(ChakraIconButton);
  function CopyButton(props) {
    const {
      registry: { translateString }
    } = props;
    return /* @__PURE__ */ jsxRuntime.jsx(ChakraIconButton_default, { title: translateString(utils.TranslatableString.CopyButton), ...props, icon: /* @__PURE__ */ jsxRuntime.jsx(icons.CopyIcon, {}) });
  }
  function MoveDownButton(props) {
    const {
      registry: { translateString }
    } = props;
    return /* @__PURE__ */ jsxRuntime.jsx(
      ChakraIconButton_default,
      {
        title: translateString(utils.TranslatableString.MoveDownButton),
        ...props,
        icon: /* @__PURE__ */ jsxRuntime.jsx(icons.ArrowDownIcon, {})
      }
    );
  }
  function MoveUpButton(props) {
    const {
      registry: { translateString }
    } = props;
    return /* @__PURE__ */ jsxRuntime.jsx(
      ChakraIconButton_default,
      {
        title: translateString(utils.TranslatableString.MoveUpButton),
        ...props,
        icon: /* @__PURE__ */ jsxRuntime.jsx(icons.ArrowUpIcon, {})
      }
    );
  }
  function RemoveButton(props) {
    const {
      registry: { translateString }
    } = props;
    return /* @__PURE__ */ jsxRuntime.jsx(
      ChakraIconButton_default,
      {
        title: translateString(utils.TranslatableString.RemoveButton),
        ...props,
        icon: /* @__PURE__ */ jsxRuntime.jsx(icons.DeleteIcon, {})
      }
    );
  }
  function FieldErrorTemplate(props) {
    const { errors = [], idSchema } = props;
    if (errors.length === 0) {
      return null;
    }
    const id = utils.errorId(idSchema);
    return /* @__PURE__ */ jsxRuntime.jsx(react$1.List, { children: errors.map((error, i) => {
      return /* @__PURE__ */ jsxRuntime.jsx(react$1.ListItem, { children: /* @__PURE__ */ jsxRuntime.jsx(react$1.FormErrorMessage, { id, children: error }) }, i);
    }) });
  }
  function FieldHelpTemplate(props) {
    const { idSchema, help } = props;
    if (!help) {
      return null;
    }
    const id = utils.helpId(idSchema);
    return /* @__PURE__ */ jsxRuntime.jsx(react$1.FormHelperText, { id, children: help });
  }
  function FieldTemplate(props) {
    const {
      id,
      children,
      classNames,
      style,
      disabled,
      displayLabel,
      hidden,
      label,
      onDropPropertyClick,
      onKeyChange,
      readonly,
      registry,
      required,
      rawErrors = [],
      errors,
      help,
      description,
      rawDescription,
      schema,
      uiSchema
    } = props;
    const uiOptions = utils.getUiOptions(uiSchema);
    const WrapIfAdditionalTemplate2 = utils.getTemplate(
      "WrapIfAdditionalTemplate",
      registry,
      uiOptions
    );
    if (hidden) {
      return /* @__PURE__ */ jsxRuntime.jsx("div", { style: { display: "none" }, children });
    }
    return /* @__PURE__ */ jsxRuntime.jsx(
      WrapIfAdditionalTemplate2,
      {
        classNames,
        style,
        disabled,
        id,
        label,
        onDropPropertyClick,
        onKeyChange,
        readonly,
        required,
        schema,
        uiSchema,
        registry,
        children: /* @__PURE__ */ jsxRuntime.jsxs(react$1.FormControl, { isRequired: required, isInvalid: rawErrors && rawErrors.length > 0, children: [
          children,
          displayLabel && rawDescription ? /* @__PURE__ */ jsxRuntime.jsx(react$1.Text, { mt: 2, children: description }) : null,
          errors,
          help
        ] })
      }
    );
  }
  function ObjectFieldTemplate(props) {
    const {
      description,
      title,
      properties,
      required,
      disabled,
      readonly,
      uiSchema,
      idSchema,
      schema,
      formData,
      onAddClick,
      registry
    } = props;
    const uiOptions = utils.getUiOptions(uiSchema);
    const TitleFieldTemplate = utils.getTemplate("TitleFieldTemplate", registry, uiOptions);
    const DescriptionFieldTemplate = utils.getTemplate(
      "DescriptionFieldTemplate",
      registry,
      uiOptions
    );
    const {
      ButtonTemplates: { AddButton: AddButton2 }
    } = registry.templates;
    return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      title && /* @__PURE__ */ jsxRuntime.jsx(
        TitleFieldTemplate,
        {
          id: utils.titleId(idSchema),
          title,
          required,
          schema,
          uiSchema,
          registry
        }
      ),
      description && /* @__PURE__ */ jsxRuntime.jsx(
        DescriptionFieldTemplate,
        {
          id: utils.descriptionId(idSchema),
          description,
          schema,
          uiSchema,
          registry
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsxs(react$1.Grid, { gap: description ? 2 : 6, mb: 4, children: [
        properties.map(
          (element, index) => element.hidden ? element.content : /* @__PURE__ */ jsxRuntime.jsx(react$1.GridItem, { children: element.content }, `${idSchema.$id}-${element.name}-${index}`)
        ),
        utils.canExpand(schema, uiSchema, formData) && /* @__PURE__ */ jsxRuntime.jsx(react$1.GridItem, { justifySelf: "flex-end", children: /* @__PURE__ */ jsxRuntime.jsx(
          AddButton2,
          {
            className: "object-property-expand",
            onClick: onAddClick(schema),
            disabled: disabled || readonly,
            uiSchema,
            registry
          }
        ) })
      ] })
    ] });
  }
  function SubmitButton({ uiSchema }) {
    const { submitText, norender, props: submitButtonProps } = utils.getSubmitButtonOptions(uiSchema);
    if (norender) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntime.jsx(react$1.Box, { marginTop: 3, children: /* @__PURE__ */ jsxRuntime.jsx(react$1.Button, { type: "submit", variant: "solid", ...submitButtonProps, children: submitText }) });
  }
  function TitleField({
    id,
    title
  }) {
    return /* @__PURE__ */ jsxRuntime.jsxs(react$1.Box, { id, mt: 1, mb: 4, children: [
      /* @__PURE__ */ jsxRuntime.jsx(react$1.Heading, { as: "h5", children: title }),
      /* @__PURE__ */ jsxRuntime.jsx(react$1.Divider, {})
    ] });
  }
  function WrapIfAdditionalTemplate(props) {
    const {
      children,
      classNames,
      style,
      disabled,
      id,
      label,
      onDropPropertyClick,
      onKeyChange,
      readonly,
      registry,
      required,
      schema,
      uiSchema
    } = props;
    const { templates, translateString } = registry;
    const { RemoveButton: RemoveButton2 } = templates.ButtonTemplates;
    const keyLabel = translateString(utils.TranslatableString.KeyLabel, [label]);
    const additional = utils.ADDITIONAL_PROPERTY_FLAG in schema;
    if (!additional) {
      return /* @__PURE__ */ jsxRuntime.jsx("div", { className: classNames, style, children });
    }
    const handleBlur = ({ target }) => onKeyChange(target.value);
    return /* @__PURE__ */ jsxRuntime.jsxs(react$1.Grid, { className: classNames, style, alignItems: "center", gap: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsx(react$1.GridItem, { children: /* @__PURE__ */ jsxRuntime.jsxs(react$1.FormControl, { isRequired: required, children: [
        /* @__PURE__ */ jsxRuntime.jsx(react$1.FormLabel, { htmlFor: `${id}-key`, id: `${id}-key-label`, children: keyLabel }),
        /* @__PURE__ */ jsxRuntime.jsx(
          react$1.Input,
          {
            defaultValue: label,
            disabled: disabled || readonly,
            id: `${id}-key`,
            name: `${id}-key`,
            onBlur: !readonly ? handleBlur : void 0,
            type: "text",
            mb: 1
          }
        )
      ] }) }),
      /* @__PURE__ */ jsxRuntime.jsx(react$1.GridItem, { children }),
      /* @__PURE__ */ jsxRuntime.jsx(react$1.GridItem, { children: /* @__PURE__ */ jsxRuntime.jsx(
        RemoveButton2,
        {
          disabled: disabled || readonly,
          onClick: onDropPropertyClick(label),
          uiSchema,
          registry
        }
      ) })
    ] }, `${id}-key`);
  }

  // src/Templates/Templates.ts
  function generateTemplates() {
    return {
      ArrayFieldItemTemplate,
      ArrayFieldTemplate,
      BaseInputTemplate,
      ButtonTemplates: {
        CopyButton,
        AddButton,
        MoveDownButton,
        MoveUpButton,
        RemoveButton,
        SubmitButton
      },
      DescriptionFieldTemplate: DescriptionField,
      ErrorListTemplate: ErrorList,
      FieldErrorTemplate,
      FieldHelpTemplate,
      FieldTemplate,
      ObjectFieldTemplate,
      TitleFieldTemplate: TitleField,
      WrapIfAdditionalTemplate
    };
  }
  var Templates_default = generateTemplates();
  function DateElement(props) {
    const { SelectWidget: SelectWidget2 } = props.registry.widgets;
    const value = props.value ? props.value : void 0;
    return /* @__PURE__ */ jsxRuntime.jsx(
      SelectWidget2,
      {
        ...props,
        label: "",
        className: "form-control",
        onChange: (elemValue) => props.select(props.type, elemValue),
        options: {
          enumOptions: utils.dateRangeOptions(props.range[0], props.range[1])
        },
        placeholder: props.type,
        schema: { type: "integer" },
        value,
        "aria-describedby": utils.ariaDescribedByIds(props.name)
      }
    );
  }
  var readyForChange = (state) => {
    return Object.keys(state).every((key) => typeof state[key] !== "undefined" && state[key] !== -1);
  };
  function AltDateWidget(props) {
    const { autofocus, disabled, id, onBlur, onChange, onFocus, options, readonly, registry, showTime, value } = props;
    const { translateString } = registry;
    const [state, setState] = react.useState(utils.parseDateString(value, showTime));
    react.useEffect(() => {
      setState(utils.parseDateString(value, showTime));
    }, [showTime, value]);
    const handleChange = (property, nextValue) => {
      const nextState = {
        ...state,
        [property]: typeof nextValue === "undefined" ? -1 : nextValue
      };
      if (readyForChange(nextState)) {
        onChange(utils.toDateString(nextState, showTime));
      } else {
        setState(nextState);
      }
    };
    const handleNow = (event) => {
      event.preventDefault();
      if (disabled || readonly) {
        return;
      }
      const nextState = utils.parseDateString((/* @__PURE__ */ new Date()).toJSON(), showTime);
      onChange(utils.toDateString(nextState, showTime));
    };
    const handleClear = (event) => {
      event.preventDefault();
      if (disabled || readonly) {
        return;
      }
      onChange(void 0);
    };
    return /* @__PURE__ */ jsxRuntime.jsxs(react$1.Box, { children: [
      /* @__PURE__ */ jsxRuntime.jsx(react$1.Box, { display: "flex", flexWrap: "wrap", alignItems: "center", children: utils.getDateElementProps(
        state,
        showTime,
        options.yearsRange,
        options.format
      ).map((elemProps, i) => {
        const elemId = id + "_" + elemProps.type;
        return /* @__PURE__ */ jsxRuntime.jsx(react$1.Box, { mr: "2", mb: "2", children: /* @__PURE__ */ jsxRuntime.jsx(
          DateElement,
          {
            ...props,
            ...elemProps,
            autofocus: autofocus && i === 0,
            disabled,
            id: elemId,
            name: id,
            onBlur,
            onFocus,
            readonly,
            registry,
            select: handleChange,
            value: elemProps.value < 0 ? "" : elemProps.value
          }
        ) }, elemId);
      }) }),
      /* @__PURE__ */ jsxRuntime.jsxs(react$1.Box, { display: "flex", children: [
        !options.hideNowButton && /* @__PURE__ */ jsxRuntime.jsx(react$1.Button, { onClick: (e) => handleNow(e), mr: "2", children: translateString(utils.TranslatableString.NowLabel) }),
        !options.hideClearButton && /* @__PURE__ */ jsxRuntime.jsx(react$1.Button, { onClick: (e) => handleClear(e), children: translateString(utils.TranslatableString.ClearLabel) })
      ] })
    ] });
  }
  AltDateWidget.defaultProps = {
    autofocus: false,
    disabled: false,
    readonly: false,
    showTime: false,
    options: {
      yearsRange: [1900, (/* @__PURE__ */ new Date()).getFullYear() + 2]
    }
  };
  var AltDateWidget_default = AltDateWidget;
  function AltDateTimeWidget(props) {
    const { AltDateWidget: AltDateWidget2 } = props.registry.widgets;
    return /* @__PURE__ */ jsxRuntime.jsx(AltDateWidget2, { ...props, showTime: true });
  }
  AltDateTimeWidget.defaultProps = {
    ...AltDateWidget_default.defaultProps,
    showTime: true
  };
  var AltDateTimeWidget_default = AltDateTimeWidget;
  function CheckboxWidget(props) {
    const {
      id,
      value,
      disabled,
      readonly,
      onChange,
      onBlur,
      onFocus,
      label,
      hideLabel,
      registry,
      options,
      uiSchema,
      schema
    } = props;
    const chakraProps = getChakra({ uiSchema });
    const required = utils.schemaRequiresTrueValue(schema);
    const DescriptionFieldTemplate = utils.getTemplate(
      "DescriptionFieldTemplate",
      registry,
      options
    );
    const description = options.description || schema.description;
    const _onChange = ({ target: { checked } }) => onChange(checked);
    const _onBlur = ({ target }) => onBlur(id, target && target.value);
    const _onFocus = ({ target }) => onFocus(id, target && target.value);
    return /* @__PURE__ */ jsxRuntime.jsxs(react$1.FormControl, { mb: 1, ...chakraProps, isRequired: required, children: [
      !hideLabel && !!description && /* @__PURE__ */ jsxRuntime.jsx(
        DescriptionFieldTemplate,
        {
          id: utils.descriptionId(id),
          description,
          schema,
          uiSchema,
          registry
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        react$1.Checkbox,
        {
          id,
          name: id,
          isChecked: typeof value === "undefined" ? false : value,
          isDisabled: disabled || readonly,
          onChange: _onChange,
          onBlur: _onBlur,
          onFocus: _onFocus,
          "aria-describedby": utils.ariaDescribedByIds(id),
          children: utils.labelValue(/* @__PURE__ */ jsxRuntime.jsx(react$1.Text, { children: label }), hideLabel || !label)
        }
      )
    ] });
  }
  function CheckboxesWidget(props) {
    const {
      id,
      disabled,
      options,
      value,
      readonly,
      onChange,
      onBlur,
      onFocus,
      required,
      label,
      hideLabel,
      uiSchema,
      rawErrors = []
    } = props;
    const { enumOptions, enumDisabled, emptyValue } = options;
    const chakraProps = getChakra({ uiSchema });
    const checkboxesValues = Array.isArray(value) ? value : [value];
    const _onBlur = ({ target }) => onBlur(id, utils.enumOptionsValueForIndex(target && target.value, enumOptions, emptyValue));
    const _onFocus = ({ target }) => onFocus(id, utils.enumOptionsValueForIndex(target && target.value, enumOptions, emptyValue));
    const row = options ? options.inline : false;
    const selectedIndexes = utils.enumOptionsIndexForValue(value, enumOptions, true);
    return /* @__PURE__ */ jsxRuntime.jsxs(
      react$1.FormControl,
      {
        mb: 1,
        ...chakraProps,
        isDisabled: disabled || readonly,
        isRequired: required,
        isReadOnly: readonly,
        isInvalid: rawErrors && rawErrors.length > 0,
        children: [
          utils.labelValue(
            /* @__PURE__ */ jsxRuntime.jsx(react$1.FormLabel, { htmlFor: id, id: `${id}-label`, children: label }),
            hideLabel || !label
          ),
          /* @__PURE__ */ jsxRuntime.jsx(
            react$1.CheckboxGroup,
            {
              onChange: (option) => onChange(utils.enumOptionsValueForIndex(option, enumOptions, emptyValue)),
              defaultValue: selectedIndexes,
              "aria-describedby": utils.ariaDescribedByIds(id),
              children: /* @__PURE__ */ jsxRuntime.jsx(react$1.Stack, { direction: row ? "row" : "column", children: Array.isArray(enumOptions) && enumOptions.map((option, index) => {
                const checked = utils.enumOptionsIsSelected(option.value, checkboxesValues);
                const itemDisabled = Array.isArray(enumDisabled) && enumDisabled.indexOf(option.value) !== -1;
                return /* @__PURE__ */ jsxRuntime.jsx(
                  react$1.Checkbox,
                  {
                    id: utils.optionId(id, index),
                    name: id,
                    value: String(index),
                    isChecked: checked,
                    isDisabled: disabled || itemDisabled || readonly,
                    onBlur: _onBlur,
                    onFocus: _onFocus,
                    children: option.label && /* @__PURE__ */ jsxRuntime.jsx(react$1.Text, { children: option.label })
                  },
                  index
                );
              }) })
            }
          )
        ]
      }
    );
  }
  function RadioWidget({
    id,
    options,
    value,
    required,
    disabled,
    readonly,
    label,
    hideLabel,
    onChange,
    onBlur,
    onFocus,
    uiSchema
  }) {
    const { enumOptions, enumDisabled, emptyValue } = options;
    const chakraProps = getChakra({ uiSchema });
    const _onChange = (nextValue) => onChange(utils.enumOptionsValueForIndex(nextValue, enumOptions, emptyValue));
    const _onBlur = ({ target: { value: value2 } }) => onBlur(id, utils.enumOptionsValueForIndex(value2, enumOptions, emptyValue));
    const _onFocus = ({ target: { value: value2 } }) => onFocus(id, utils.enumOptionsValueForIndex(value2, enumOptions, emptyValue));
    const row = options ? options.inline : false;
    const selectedIndex = utils.enumOptionsIndexForValue(value, enumOptions) ?? null;
    return /* @__PURE__ */ jsxRuntime.jsxs(react$1.FormControl, { mb: 1, ...chakraProps, isDisabled: disabled || readonly, isRequired: required, isReadOnly: readonly, children: [
      utils.labelValue(
        /* @__PURE__ */ jsxRuntime.jsx(react$1.FormLabel, { htmlFor: id, id: `${id}-label`, children: label }),
        hideLabel || !label
      ),
      /* @__PURE__ */ jsxRuntime.jsx(
        react$1.RadioGroup,
        {
          onChange: _onChange,
          onBlur: _onBlur,
          onFocus: _onFocus,
          value: selectedIndex,
          name: id,
          "aria-describedby": utils.ariaDescribedByIds(id),
          children: /* @__PURE__ */ jsxRuntime.jsx(react$1.Stack, { direction: row ? "row" : "column", children: Array.isArray(enumOptions) && enumOptions.map((option, index) => {
            const itemDisabled = Array.isArray(enumDisabled) && enumDisabled.indexOf(option.value) !== -1;
            return /* @__PURE__ */ jsxRuntime.jsx(
              react$1.Radio,
              {
                value: String(index),
                id: utils.optionId(id, index),
                disabled: disabled || itemDisabled || readonly,
                children: option.label
              },
              index
            );
          }) })
        }
      )
    ] });
  }
  function RangeWidget({
    value,
    readonly,
    disabled,
    onBlur,
    onFocus,
    options,
    schema,
    uiSchema,
    onChange,
    label,
    hideLabel,
    id
  }) {
    const chakraProps = getChakra({ uiSchema });
    const sliderWidgetProps = { value, label, id, ...utils.rangeSpec(schema) };
    const _onChange = (value2) => onChange(value2 === void 0 ? options.emptyValue : value2);
    const _onBlur = ({ target }) => onBlur(id, target && target.value);
    const _onFocus = ({ target }) => onFocus(id, target && target.value);
    return /* @__PURE__ */ jsxRuntime.jsxs(react$1.FormControl, { mb: 1, ...chakraProps, children: [
      utils.labelValue(/* @__PURE__ */ jsxRuntime.jsx(react$1.FormLabel, { htmlFor: id, children: label }), hideLabel || !label),
      /* @__PURE__ */ jsxRuntime.jsxs(
        react$1.Slider,
        {
          ...sliderWidgetProps,
          id,
          name: id,
          isDisabled: disabled || readonly,
          onChange: _onChange,
          onBlur: _onBlur,
          onFocus: _onFocus,
          "aria-describedby": utils.ariaDescribedByIds(id),
          children: [
            /* @__PURE__ */ jsxRuntime.jsx(react$1.SliderTrack, { children: /* @__PURE__ */ jsxRuntime.jsx(react$1.SliderFilledTrack, {}) }),
            /* @__PURE__ */ jsxRuntime.jsx(react$1.SliderThumb, {})
          ]
        }
      )
    ] });
  }
  function SelectWidget(props) {
    const {
      id,
      options,
      label,
      hideLabel,
      placeholder,
      multiple,
      required,
      disabled,
      readonly,
      value,
      autofocus,
      onChange,
      onBlur,
      onFocus,
      rawErrors = [],
      uiSchema,
      schema
    } = props;
    const { enumOptions, enumDisabled, emptyValue } = options;
    const chakraProps = getChakra({ uiSchema });
    const _onMultiChange = (e) => {
      return onChange(
        utils.enumOptionsValueForIndex(
          e.map((v) => {
            return v.value;
          }),
          enumOptions,
          emptyValue
        )
      );
    };
    const _onChange = (e) => {
      return onChange(utils.enumOptionsValueForIndex(e.value, enumOptions, emptyValue));
    };
    const _onBlur = ({ target }) => onBlur(id, utils.enumOptionsValueForIndex(target && target.value, enumOptions, emptyValue));
    const _onFocus = ({ target }) => onFocus(id, utils.enumOptionsValueForIndex(target && target.value, enumOptions, emptyValue));
    const showPlaceholderOption = !multiple && schema.default === void 0;
    const { valueLabelMap, displayEnumOptions } = react.useMemo(() => {
      const valueLabelMap2 = {};
      let displayEnumOptions2 = [];
      if (Array.isArray(enumOptions)) {
        displayEnumOptions2 = enumOptions.map((option, index) => {
          const { value: value2, label: label2 } = option;
          valueLabelMap2[index] = label2 || String(value2);
          return {
            label: label2,
            value: String(index),
            isDisabled: Array.isArray(enumDisabled) && enumDisabled.indexOf(value2) !== -1
          };
        });
        if (showPlaceholderOption) {
          displayEnumOptions2.unshift({ value: "", label: placeholder || "" });
        }
      }
      return { valueLabelMap: valueLabelMap2, displayEnumOptions: displayEnumOptions2 };
    }, [enumDisabled, enumOptions, placeholder, showPlaceholderOption]);
    const isMultiple = typeof multiple !== "undefined" && multiple !== false && Boolean(enumOptions);
    const selectedIndex = utils.enumOptionsIndexForValue(value, enumOptions, isMultiple);
    const formValue = isMultiple ? (selectedIndex || []).map((i) => {
      return {
        label: valueLabelMap[i],
        value: i
      };
    }) : {
      label: valueLabelMap[selectedIndex] || "",
      selectedIndex
    };
    return /* @__PURE__ */ jsxRuntime.jsxs(
      react$1.FormControl,
      {
        mb: 1,
        ...chakraProps,
        isDisabled: disabled || readonly,
        isRequired: required,
        isReadOnly: readonly,
        isInvalid: rawErrors && rawErrors.length > 0,
        children: [
          utils.labelValue(
            /* @__PURE__ */ jsxRuntime.jsx(react$1.FormLabel, { htmlFor: id, id: `${id}-label`, children: label }),
            hideLabel || !label
          ),
          /* @__PURE__ */ jsxRuntime.jsx(
            chakraReactSelect.Select,
            {
              inputId: id,
              name: id,
              isMulti: isMultiple,
              options: displayEnumOptions,
              placeholder,
              closeMenuOnSelect: !isMultiple,
              onBlur: _onBlur,
              onChange: isMultiple ? _onMultiChange : _onChange,
              onFocus: _onFocus,
              autoFocus: autofocus,
              value: formValue,
              "aria-describedby": utils.ariaDescribedByIds(id)
            }
          )
        ]
      }
    );
  }
  function TextareaWidget({
    id,
    placeholder,
    value,
    label,
    hideLabel,
    disabled,
    autofocus,
    readonly,
    onBlur,
    onFocus,
    onChange,
    options,
    uiSchema,
    required,
    rawErrors
  }) {
    const chakraProps = getChakra({ uiSchema });
    const _onChange = ({ target: { value: value2 } }) => onChange(value2 === "" ? options.emptyValue : value2);
    const _onBlur = ({ target }) => onBlur(id, target && target.value);
    const _onFocus = ({ target }) => onFocus(id, target && target.value);
    return /* @__PURE__ */ jsxRuntime.jsxs(
      react$1.FormControl,
      {
        mb: 1,
        ...chakraProps,
        isDisabled: disabled || readonly,
        isRequired: required,
        isReadOnly: readonly,
        isInvalid: rawErrors && rawErrors.length > 0,
        children: [
          utils.labelValue(/* @__PURE__ */ jsxRuntime.jsx(react$1.FormLabel, { htmlFor: id, children: label }), hideLabel || !label),
          /* @__PURE__ */ jsxRuntime.jsx(
            react$1.Textarea,
            {
              id,
              name: id,
              value: value ?? "",
              placeholder,
              autoFocus: autofocus,
              onChange: _onChange,
              onBlur: _onBlur,
              onFocus: _onFocus,
              rows: options.rows,
              "aria-describedby": utils.ariaDescribedByIds(id)
            }
          )
        ]
      }
    );
  }
  function UpDownWidget(props) {
    const { id, uiSchema, readonly, disabled, label, hideLabel, value, onChange, onBlur, onFocus, rawErrors, required } = props;
    const chakraProps = getChakra({ uiSchema });
    const _onChange = (value2) => onChange(value2);
    const _onBlur = ({ target }) => onBlur(id, target && target.value);
    const _onFocus = ({ target }) => onFocus(id, target && target.value);
    return /* @__PURE__ */ jsxRuntime.jsxs(
      react$1.FormControl,
      {
        mb: 1,
        ...chakraProps,
        isDisabled: disabled || readonly,
        isRequired: required,
        isReadOnly: readonly,
        isInvalid: rawErrors && rawErrors.length > 0,
        children: [
          utils.labelValue(/* @__PURE__ */ jsxRuntime.jsx(react$1.FormLabel, { htmlFor: id, children: label }), hideLabel || !label),
          /* @__PURE__ */ jsxRuntime.jsxs(
            react$1.NumberInput,
            {
              value: value ?? "",
              onChange: _onChange,
              onBlur: _onBlur,
              onFocus: _onFocus,
              "aria-describedby": utils.ariaDescribedByIds(id),
              children: [
                /* @__PURE__ */ jsxRuntime.jsx(react$1.NumberInputField, { id, name: id }),
                /* @__PURE__ */ jsxRuntime.jsxs(react$1.NumberInputStepper, { children: [
                  /* @__PURE__ */ jsxRuntime.jsx(react$1.NumberIncrementStepper, {}),
                  /* @__PURE__ */ jsxRuntime.jsx(react$1.NumberDecrementStepper, {})
                ] })
              ]
            }
          )
        ]
      }
    );
  }

  // src/Widgets/Widgets.ts
  function generateWidgets() {
    return {
      AltDateTimeWidget: AltDateTimeWidget_default,
      AltDateWidget: AltDateWidget_default,
      CheckboxWidget,
      CheckboxesWidget,
      RadioWidget,
      RangeWidget,
      SelectWidget,
      TextareaWidget,
      UpDownWidget
    };
  }
  var Widgets_default = generateWidgets();

  // src/Theme/Theme.tsx
  function generateTheme() {
    return {
      templates: generateTemplates(),
      widgets: generateWidgets()
    };
  }
  var Theme_default = generateTheme();

  // src/Form/Form.tsx
  function generateForm() {
    return core.withTheme(generateTheme());
  }
  var Form_default = generateForm();
  var CSSReset = () => /* @__PURE__ */ jsxRuntime.jsx(
    react$2.Global,
    {
      styles: `
      html {
        line-height: 1.5;
        -webkit-text-size-adjust: 100%;
        font-family: system-ui, sans-serif;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
        -moz-osx-font-smoothing: grayscale;
        touch-action: manipulation;
      }
      body {
        position: relative;
        min-height: 100%;
        font-feature-settings: 'kern';
      }
      *,
      *::before,
      *::after {
        border-width: 0;
        border-style: solid;
        box-sizing: border-box;
      }
      main {
        display: block;
      }
      hr {
        border-top-width: 1px;
        box-sizing: content-box;
        height: 0;
        overflow: visible;
      }
      pre,
      code,
      kbd,
      samp {
        font-family: SFMono-Regular,  Menlo, Monaco, Consolas, monospace;
        font-size: 1em;
      }
      a {
        background-color: transparent;
        color: inherit;
        text-decoration: inherit;
      }
      abbr[title] {
        border-bottom: none;
        text-decoration: underline;
        -webkit-text-decoration: underline dotted;
        text-decoration: underline dotted;
      }
      b,
      strong {
        font-weight: bold;
      }
      small {
        font-size: 80%;
      }
      sub,
      sup {
        font-size: 75%;
        line-height: 0;
        position: relative;
        vertical-align: baseline;
      }
      sub {
        bottom: -0.25em;
      }
      sup {
        top: -0.5em;
      }
      img {
        border-style: none;
      }
      button,
      input,
      optgroup,
      select,
      textarea {
        font-family: inherit;
        font-size: 100%;
        line-height: 1.15;
        margin: 0;
      }
      button,
      input {
        overflow: visible;
      }
      button,
      select {
        text-transform: none;
      }
      button::-moz-focus-inner,
      [type="button"]::-moz-focus-inner,
      [type="reset"]::-moz-focus-inner,
      [type="submit"]::-moz-focus-inner {
        border-style: none;
        padding: 0;
      }
      fieldset {
        padding: 0.35em 0.75em 0.625em;
      }
      legend {
        box-sizing: border-box;
        color: inherit;
        display: table;
        max-width: 100%;
        padding: 0;
        white-space: normal;
      }
      progress {
        vertical-align: baseline;
      }
      textarea {
        overflow: auto;
      }
      [type="checkbox"],
      [type="radio"] {
        box-sizing: border-box;
        padding: 0;
      }
      [type="number"]::-webkit-inner-spin-button,
      [type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none !important;
      }
      input[type="number"] {
        -moz-appearance: textfield;
      }
      [type="search"] {
        -webkit-appearance: textfield;
        outline-offset: -2px;
      }
      [type="search"]::-webkit-search-decoration {
        -webkit-appearance: none !important;
      }
      ::-webkit-file-upload-button {
        -webkit-appearance: button;
        font: inherit;
      }
      details {
        display: block;
      }
      summary {
        display: list-item;
      }
      template {
        display: none;
      }
      [hidden] {
        display: none !important;
      }
      body,
      blockquote,
      dl,
      dd,
      h1,
      h2,
      h3,
      h4,
      h5,
      h6,
      hr,
      figure,
      p,
      pre {
        margin: 0;
      }
      button {
        background: transparent;
        padding: 0;
      }
      fieldset {
        margin: 0;
        padding: 0;
      }
      ol,
      ul {
        margin: 0;
        padding: 0;
      }
      textarea {
        resize: vertical;
      }
      button,
      [role="button"] {
        cursor: pointer;
      }
      button::-moz-focus-inner {
        border: 0 !important;
      }
      table {
        border-collapse: collapse;
      }
      h1,
      h2,
      h3,
      h4,
      h5,
      h6 {
        font-size: inherit;
        font-weight: inherit;
      }
      button,
      input,
      optgroup,
      select,
      textarea {
        padding: 0;
        line-height: inherit;
        color: inherit;
      }
      img,
      svg,
      video,
      canvas,
      audio,
      iframe,
      embed,
      object {
        display: block;
      }
      img,
      video {
        max-width: 100%;
        height: auto;
      }
      [data-js-focus-visible] :focus:not([data-focus-visible-added]) {
        outline: none;
        box-shadow: none;
      }
      select::-ms-expand {
        display: none;
      }
      input {
        border-width: revert;
        border-color: revert;
        border-style: revert;
      }
      .array-item > hr {
        margin-top: 16px;
        margin-bottom: 16px;
      }
    `
    }
  );
  var CssReset_default = CSSReset;
  var memoizedCreateCacheWithContainer = weakMemoize((container) => {
    const newCache = createCache({ container, key: "rjsf" });
    return newCache;
  });
  var __createChakraFrameProvider = (props) => ({ document }) => {
    return /* @__PURE__ */ jsxRuntime.jsx("div", { style: { margin: 2 }, children: /* @__PURE__ */ jsxRuntime.jsx(react$2.CacheProvider, { value: memoizedCreateCacheWithContainer(document.head), children: /* @__PURE__ */ jsxRuntime.jsxs(react$1.ChakraProvider, { resetCSS: false, children: [
      /* @__PURE__ */ jsxRuntime.jsx(CssReset_default, {}),
      props.children
    ] }) }) });
  };

  // src/index.ts
  var src_default = Form_default;

  exports.Form = Form_default;
  exports.Templates = Templates_default;
  exports.Theme = Theme_default;
  exports.Widgets = Widgets_default;
  exports.__createChakraFrameProvider = __createChakraFrameProvider;
  exports.default = src_default;
  exports.generateForm = generateForm;
  exports.generateTemplates = generateTemplates;
  exports.generateTheme = generateTheme;
  exports.generateWidgets = generateWidgets;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
