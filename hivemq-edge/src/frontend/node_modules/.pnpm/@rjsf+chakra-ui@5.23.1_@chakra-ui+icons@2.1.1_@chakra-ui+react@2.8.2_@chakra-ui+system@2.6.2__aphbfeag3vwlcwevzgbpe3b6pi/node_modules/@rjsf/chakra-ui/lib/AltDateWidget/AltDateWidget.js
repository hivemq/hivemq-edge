import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useEffect, useState } from 'react';
import { ariaDescribedByIds, dateRangeOptions, getDateElementProps, parseDateString, toDateString, TranslatableString, } from '@rjsf/utils';
import { Box, Button } from '@chakra-ui/react';
function DateElement(props) {
    const { SelectWidget } = props.registry.widgets;
    const value = props.value ? props.value : undefined;
    return (_jsx(SelectWidget, { ...props, label: '', className: 'form-control', onChange: (elemValue) => props.select(props.type, elemValue), options: {
            enumOptions: dateRangeOptions(props.range[0], props.range[1]),
        }, placeholder: props.type, schema: { type: 'integer' }, value: value, "aria-describedby": ariaDescribedByIds(props.name) }));
}
const readyForChange = (state) => {
    return Object.keys(state).every((key) => typeof state[key] !== 'undefined' && state[key] !== -1);
};
function AltDateWidget(props) {
    const { autofocus, disabled, id, onBlur, onChange, onFocus, options, readonly, registry, showTime, value } = props;
    const { translateString } = registry;
    const [state, setState] = useState(parseDateString(value, showTime));
    useEffect(() => {
        setState(parseDateString(value, showTime));
    }, [showTime, value]);
    const handleChange = (property, nextValue) => {
        const nextState = {
            ...state,
            [property]: typeof nextValue === 'undefined' ? -1 : nextValue,
        };
        if (readyForChange(nextState)) {
            onChange(toDateString(nextState, showTime));
        }
        else {
            setState(nextState);
        }
    };
    const handleNow = (event) => {
        event.preventDefault();
        if (disabled || readonly) {
            return;
        }
        const nextState = parseDateString(new Date().toJSON(), showTime);
        onChange(toDateString(nextState, showTime));
    };
    const handleClear = (event) => {
        event.preventDefault();
        if (disabled || readonly) {
            return;
        }
        onChange(undefined);
    };
    return (_jsxs(Box, { children: [_jsx(Box, { display: 'flex', flexWrap: 'wrap', alignItems: 'center', children: getDateElementProps(state, showTime, options.yearsRange, options.format).map((elemProps, i) => {
                    const elemId = id + '_' + elemProps.type;
                    return (_jsx(Box, { mr: '2', mb: '2', children: _jsx(DateElement, { ...props, ...elemProps, autofocus: autofocus && i === 0, disabled: disabled, id: elemId, name: id, onBlur: onBlur, onFocus: onFocus, readonly: readonly, registry: registry, select: handleChange, value: elemProps.value < 0 ? '' : elemProps.value }) }, elemId));
                }) }), _jsxs(Box, { display: 'flex', children: [!options.hideNowButton && (_jsx(Button, { onClick: (e) => handleNow(e), mr: '2', children: translateString(TranslatableString.NowLabel) })), !options.hideClearButton && (_jsx(Button, { onClick: (e) => handleClear(e), children: translateString(TranslatableString.ClearLabel) }))] })] }));
}
AltDateWidget.defaultProps = {
    autofocus: false,
    disabled: false,
    readonly: false,
    showTime: false,
    options: {
        yearsRange: [1900, new Date().getFullYear() + 2],
    },
};
export default AltDateWidget;
//# sourceMappingURL=AltDateWidget.js.map