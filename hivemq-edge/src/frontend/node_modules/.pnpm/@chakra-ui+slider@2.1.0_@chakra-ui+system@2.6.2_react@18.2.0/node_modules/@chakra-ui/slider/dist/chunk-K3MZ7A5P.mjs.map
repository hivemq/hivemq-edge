{"version":3,"sources":["../src/use-range-slider.ts"],"sourcesContent":["import { usePanEvent } from \"@chakra-ui/react-use-pan-event\"\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\"\nimport { useCallbackRef } from \"@chakra-ui/react-use-callback-ref\"\nimport { useUpdateEffect } from \"@chakra-ui/react-use-update-effect\"\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\"\nimport type { PropGetter, RequiredPropGetter } from \"@chakra-ui/react-types\"\nimport { ariaAttr, callAllHandlers, dataAttr } from \"@chakra-ui/utils\"\nimport {\n  percentToValue,\n  roundValueToStep,\n  valueToPercent,\n  clampValue,\n} from \"@chakra-ui/number-utils\"\nimport { useCallback, useMemo, useRef, useState, useId } from \"react\"\nimport { getIds, getIsReversed, getStyles, orient } from \"./slider-utils\"\nimport { useSizes } from \"@chakra-ui/react-use-size\"\n\nexport interface UseRangeSliderProps {\n  /**\n   * The minimum allowed value of the slider. Cannot be greater than max.\n   * @default 0\n   */\n  min?: number\n  /**\n   * The maximum allowed value of the slider. Cannot be less than min.\n   * @default 100\n   */\n  max?: number\n  /**\n   * The step in which increments/decrements have to be made\n   * @default 1\n   */\n  step?: number\n  /**\n   * The value of the slider in controlled mode\n   */\n  value?: number[]\n  /**\n   * The initial value of the slider in uncontrolled mode\n   */\n  defaultValue?: number[]\n  /**\n   * Orientation of the slider\n   * @default \"horizontal\"\n   */\n  orientation?: \"horizontal\" | \"vertical\"\n  /**\n   * If `true`, the value will be incremented or decremented in reverse.\n   * @default false\n   */\n  isReversed?: boolean\n\n  /**\n   * Function called when the user starts selecting a new value (by dragging or clicking)\n   */\n  onChangeStart?(value: number[]): void\n\n  /**\n   * Function called when the user is done selecting a new value (by dragging or clicking)\n   */\n  onChangeEnd?(value: number[]): void\n\n  /**\n   * Function called whenever the slider value changes  (by dragging or clicking)\n   */\n  onChange?(value: number[]): void\n\n  /**\n   * The base `id` to use for the slider and its components\n   */\n  id?: string\n  /**\n   * The name attribute of the hidden `input` field.\n   * This is particularly useful in forms\n   */\n  name?: string | string[]\n  /**\n   * If `true`, the slider will be disabled\n   * @default false\n   */\n  isDisabled?: boolean\n  /**\n   * If `true`, the slider will be in `read-only` state\n   * @default false\n   */\n  isReadOnly?: boolean\n\n  /**\n   * Function that returns the `aria-valuetext` for screen readers.\n   * It is mostly used to generate a more human-readable\n   * representation of the value for assistive technologies\n   */\n  getAriaValueText?(value: number): string\n\n  /**\n   * If `false`, the slider handle will not capture focus when value changes.\n   * @default true\n   */\n  focusThumbOnChange?: boolean\n  /**\n   * The static string to use used for `aria-valuetext`\n   */\n  \"aria-valuetext\"?: string[]\n  /**\n   * The static string to use used for `aria-label`\n   * if no visible label is used.\n   */\n  \"aria-label\"?: string[]\n  /**\n   * The static string `aria-labelledby` that points to the\n   * ID of the element that serves as label for the slider\n   */\n  \"aria-labelledby\"?: string[]\n  /**\n   * The writing mode\n   * @default \"ltr\"\n   */\n  direction?: \"ltr\" | \"rtl\"\n  /**\n   * The minimum distance between slider thumbs. Useful for preventing\n   * the thumbs from being too close together.\n   * @default 0\n   */\n  minStepsBetweenThumbs?: number\n}\n\nexport interface RangeSliderState {\n  value: number[]\n  isFocused: boolean\n  isDragging: boolean\n  getThumbPercent: (index: number) => number\n  getThumbMinValue: (index: number) => number\n  getThumbMaxValue: (index: number) => number\n}\n\nexport interface RangeSliderActions {\n  setValueAtIndex(index: number, val: number): void\n  setActiveIndex: React.Dispatch<React.SetStateAction<number>>\n  stepUp(index: number, step?: number): void\n  stepDown(index: number, step?: number): void\n  reset(): void\n}\n\n/**\n * React hook that implements an accessible range slider.\n *\n * It is an alternative to `<input type=\"range\" />`, and returns\n * prop getters for the component parts\n *\n * @see Docs     https://chakra-ui.com/docs/form/slider\n * @see WAI-ARIA https://www.w3.org/WAI/ARIA/apg/patterns/slidertwothumb/\n */\nexport function useRangeSlider(props: UseRangeSliderProps) {\n  const {\n    min = 0,\n    max = 100,\n    onChange,\n    value: valueProp,\n    defaultValue,\n    isReversed: isReversedProp,\n    direction = \"ltr\",\n    orientation = \"horizontal\",\n    id: idProp,\n    isDisabled,\n    isReadOnly,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    step = 1,\n    getAriaValueText: getAriaValueTextProp,\n    \"aria-valuetext\": ariaValueText,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    name,\n    focusThumbOnChange = true,\n    minStepsBetweenThumbs = 0,\n    ...htmlProps\n  } = props\n\n  const onChangeStart = useCallbackRef(onChangeStartProp)\n  const onChangeEnd = useCallbackRef(onChangeEndProp)\n  const getAriaValueText = useCallbackRef(getAriaValueTextProp)\n\n  const isReversed = getIsReversed({\n    isReversed: isReversedProp,\n    direction,\n    orientation,\n  })\n\n  const [valueState, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue ?? [25, 75],\n    onChange,\n  })\n\n  if (!Array.isArray(valueState)) {\n    throw new TypeError(\n      `[range-slider] You passed an invalid value for \\`value\\` or \\`defaultValue\\`, expected \\`Array\\` but got \\`${typeof valueState}\\``,\n    )\n  }\n\n  const [isDragging, setDragging] = useState(false)\n  const [isFocused, setFocused] = useState(false)\n  const [activeIndex, setActiveIndex] = useState(-1)\n\n  const isInteractive = !(isDisabled || isReadOnly)\n\n  const initialValue = useRef(valueState)\n  const value = valueState.map((val) => clampValue(val, min, max))\n\n  const spacing = minStepsBetweenThumbs * step\n  const valueBounds = getValueBounds(value, min, max, spacing)\n\n  const stateRef = useRef<{\n    eventSource: \"pointer\" | \"keyboard\" | null\n    value: number[]\n    valueBounds: Array<{ min: number; max: number }>\n  }>({\n    eventSource: null,\n    value: [],\n    valueBounds: [],\n  })\n\n  stateRef.current.value = value\n  stateRef.current.valueBounds = valueBounds\n\n  const reversedValue = value.map((val) => max - val + min)\n  const thumbValues = isReversed ? reversedValue : value\n  const thumbPercents = thumbValues.map((val) => valueToPercent(val, min, max))\n\n  const isVertical = orientation === \"vertical\"\n\n  const trackRef = useRef<HTMLElement>(null)\n  const rootRef = useRef<HTMLElement>(null)\n\n  const thumbRects = useSizes({\n    getNodes() {\n      const rootNode = rootRef.current\n      const thumbNodes =\n        rootNode?.querySelectorAll<HTMLElement>(\"[role=slider]\")\n      return thumbNodes ? Array.from(thumbNodes) : []\n    },\n  })\n\n  const reactId = useId()\n  const uuid = idProp ?? reactId\n  const ids = getIds(uuid)\n\n  const getValueFromPointer = useCallback(\n    (event: any) => {\n      if (!trackRef.current) return\n      stateRef.current.eventSource = \"pointer\"\n      const rect = trackRef.current.getBoundingClientRect()\n      const { clientX, clientY } = event.touches?.[0] ?? event\n\n      const diff = isVertical ? rect.bottom - clientY : clientX - rect.left\n      const length = isVertical ? rect.height : rect.width\n\n      let percent = diff / length\n      if (isReversed) percent = 1 - percent\n\n      return percentToValue(percent, min, max)\n    },\n    [isVertical, isReversed, max, min],\n  )\n\n  const tenSteps = (max - min) / 10\n  const oneStep = step || (max - min) / 100\n\n  const actions: RangeSliderActions = useMemo(\n    () => ({\n      setValueAtIndex(index: number, val: number) {\n        if (!isInteractive) return\n        const bounds = stateRef.current.valueBounds[index]\n        val = parseFloat(roundValueToStep(val, bounds.min, oneStep))\n        val = clampValue(val, bounds.min, bounds.max)\n        const next = [...stateRef.current.value]\n        next[index] = val\n        setValue(next)\n      },\n      setActiveIndex,\n      stepUp(index: number, step = oneStep) {\n        const valueAtIndex = stateRef.current.value[index]\n        const next = isReversed ? valueAtIndex - step : valueAtIndex + step\n        actions.setValueAtIndex(index, next)\n      },\n      stepDown(index: number, step = oneStep) {\n        const valueAtIndex = stateRef.current.value[index]\n        const next = isReversed ? valueAtIndex + step : valueAtIndex - step\n        actions.setValueAtIndex(index, next)\n      },\n      reset() {\n        setValue(initialValue.current)\n      },\n    }),\n    [oneStep, isReversed, setValue, isInteractive],\n  )\n\n  /**\n   * Keyboard interaction to ensure users can operate\n   * the slider using only their keyboard.\n   */\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const eventKey = event.key\n      const keyMap: Record<string, React.KeyboardEventHandler> = {\n        ArrowRight: () => actions.stepUp(activeIndex),\n        ArrowUp: () => actions.stepUp(activeIndex),\n        ArrowLeft: () => actions.stepDown(activeIndex),\n        ArrowDown: () => actions.stepDown(activeIndex),\n        PageUp: () => actions.stepUp(activeIndex, tenSteps),\n        PageDown: () => actions.stepDown(activeIndex, tenSteps),\n        Home: () => {\n          const { min: value } = valueBounds[activeIndex]\n          actions.setValueAtIndex(activeIndex, value)\n        },\n        End: () => {\n          const { max: value } = valueBounds[activeIndex]\n          actions.setValueAtIndex(activeIndex, value)\n        },\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        event.stopPropagation()\n        action(event)\n        stateRef.current.eventSource = \"keyboard\"\n      }\n    },\n    [actions, activeIndex, tenSteps, valueBounds],\n  )\n\n  /**\n   * Compute styles for all component parts.\n   */\n  const { getThumbStyle, rootStyle, trackStyle, innerTrackStyle } = useMemo(\n    () =>\n      getStyles({\n        isReversed,\n        orientation,\n        thumbRects,\n        thumbPercents,\n      }),\n    [isReversed, orientation, thumbPercents, thumbRects],\n  )\n\n  const focusThumb = useCallback(\n    (index?: number) => {\n      const idx = index ?? activeIndex\n      if (idx !== -1 && focusThumbOnChange) {\n        const id = ids.getThumb(idx)\n        const thumb = rootRef.current?.ownerDocument.getElementById(id)\n        if (thumb) {\n          setTimeout(() => thumb.focus())\n        }\n      }\n    },\n    [focusThumbOnChange, activeIndex, ids],\n  )\n\n  useUpdateEffect(() => {\n    if (stateRef.current.eventSource === \"keyboard\") {\n      onChangeEnd?.(stateRef.current.value)\n    }\n  }, [value, onChangeEnd])\n\n  const onPanSessionStart = (event: MouseEvent | TouchEvent | PointerEvent) => {\n    const pointValue = getValueFromPointer(event) || 0\n    const distances = stateRef.current.value.map((val) =>\n      Math.abs(val - pointValue),\n    )\n    const closest = Math.min(...distances)\n    let index = distances.indexOf(closest)\n\n    // check if the clicked thumb is stacked by checking if there are multiple\n    // thumbs at the same distance\n    const thumbsAtPosition = distances.filter(\n      (distance) => distance === closest,\n    )\n    const isThumbStacked = thumbsAtPosition.length > 1\n\n    // when two thumbs are stacked and the user clicks at a point larger than\n    // their values, pick the last thumb with the greatest index\n    if (isThumbStacked && pointValue > stateRef.current.value[index]) {\n      index = index + thumbsAtPosition.length - 1\n    }\n\n    setActiveIndex(index)\n    actions.setValueAtIndex(index, pointValue)\n    focusThumb(index)\n  }\n\n  const onPan = (event: MouseEvent | TouchEvent | PointerEvent) => {\n    if (activeIndex == -1) return\n    const pointValue = getValueFromPointer(event) || 0\n    setActiveIndex(activeIndex)\n    actions.setValueAtIndex(activeIndex, pointValue)\n    focusThumb(activeIndex)\n  }\n\n  usePanEvent(rootRef, {\n    onPanSessionStart(event) {\n      if (!isInteractive) return\n      setDragging(true)\n      onPanSessionStart(event)\n      onChangeStart?.(stateRef.current.value)\n    },\n    onPanSessionEnd() {\n      if (!isInteractive) return\n      setDragging(false)\n      onChangeEnd?.(stateRef.current.value)\n    },\n    onPan(event) {\n      if (!isInteractive) return\n      onPan(event)\n    },\n  })\n\n  const getRootProps: PropGetter = useCallback(\n    (props = {}, ref = null) => {\n      return {\n        ...props,\n        ...htmlProps,\n        id: ids.root,\n        ref: mergeRefs(ref, rootRef),\n        tabIndex: -1,\n        \"aria-disabled\": ariaAttr(isDisabled),\n        \"data-focused\": dataAttr(isFocused),\n        style: { ...props.style, ...rootStyle },\n      }\n    },\n    [htmlProps, isDisabled, isFocused, rootStyle, ids],\n  )\n\n  const getTrackProps: PropGetter = useCallback(\n    (props = {}, ref = null) => {\n      return {\n        ...props,\n        ref: mergeRefs(ref, trackRef),\n        id: ids.track,\n        \"data-disabled\": dataAttr(isDisabled),\n        style: { ...props.style, ...trackStyle },\n      }\n    },\n    [isDisabled, trackStyle, ids],\n  )\n\n  const getInnerTrackProps: PropGetter = useCallback(\n    (props = {}, ref = null) => {\n      return {\n        ...props,\n        ref,\n        id: ids.innerTrack,\n        style: {\n          ...props.style,\n          ...innerTrackStyle,\n        },\n      }\n    },\n    [innerTrackStyle, ids],\n  )\n\n  const getThumbProps: RequiredPropGetter<{ index: number }> = useCallback(\n    (props, ref = null) => {\n      const { index, ...rest } = props\n\n      const valueAtIndex = value[index]\n      if (valueAtIndex == null) {\n        throw new TypeError(\n          `[range-slider > thumb] Cannot find value at index \\`${index}\\`. The \\`value\\` or \\`defaultValue\\` length is : ${value.length}`,\n        )\n      }\n\n      const bounds = valueBounds[index]\n\n      return {\n        ...rest,\n        ref,\n        role: \"slider\",\n        tabIndex: isInteractive ? 0 : undefined,\n        id: ids.getThumb(index),\n        \"data-active\": dataAttr(isDragging && activeIndex === index),\n        \"aria-valuetext\":\n          getAriaValueText?.(valueAtIndex) ?? ariaValueText?.[index],\n        \"aria-valuemin\": bounds.min,\n        \"aria-valuemax\": bounds.max,\n        \"aria-valuenow\": valueAtIndex,\n        \"aria-orientation\": orientation,\n        \"aria-disabled\": ariaAttr(isDisabled),\n        \"aria-readonly\": ariaAttr(isReadOnly),\n        \"aria-label\": ariaLabel?.[index],\n        \"aria-labelledby\": ariaLabel?.[index]\n          ? undefined\n          : ariaLabelledBy?.[index],\n        style: { ...props.style, ...getThumbStyle(index) },\n        onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n        onFocus: callAllHandlers(props.onFocus, () => {\n          setFocused(true)\n          setActiveIndex(index)\n        }),\n        onBlur: callAllHandlers(props.onBlur, () => {\n          setFocused(false)\n          setActiveIndex(-1)\n        }),\n      }\n    },\n    [\n      ids,\n      value,\n      valueBounds,\n      isInteractive,\n      isDragging,\n      activeIndex,\n      getAriaValueText,\n      ariaValueText,\n      orientation,\n      isDisabled,\n      isReadOnly,\n      ariaLabel,\n      ariaLabelledBy,\n      getThumbStyle,\n      onKeyDown,\n      setFocused,\n    ],\n  )\n\n  const getOutputProps: PropGetter = useCallback(\n    (props = {}, ref = null) => {\n      return {\n        ...props,\n        ref,\n        id: ids.output,\n        htmlFor: value.map((v, i) => ids.getThumb(i)).join(\" \"),\n        \"aria-live\": \"off\",\n      }\n    },\n    [ids, value],\n  )\n\n  const getMarkerProps: RequiredPropGetter<{ value: number }> = useCallback(\n    (props, ref = null) => {\n      const { value: v, ...rest } = props\n\n      const isInRange = !(v < min || v > max)\n      const isHighlighted = v >= value[0] && v <= value[value.length - 1]\n\n      let percent = valueToPercent(v, min, max)\n      percent = isReversed ? 100 - percent : percent\n\n      const markerStyle: React.CSSProperties = {\n        position: \"absolute\",\n        pointerEvents: \"none\",\n        ...orient({\n          orientation,\n          vertical: { bottom: `${percent}%` },\n          horizontal: { left: `${percent}%` },\n        }),\n      }\n\n      return {\n        ...rest,\n        ref,\n        id: ids.getMarker(props.value),\n        role: \"presentation\",\n        \"aria-hidden\": true,\n        \"data-disabled\": dataAttr(isDisabled),\n        \"data-invalid\": dataAttr(!isInRange),\n        \"data-highlighted\": dataAttr(isHighlighted),\n        style: {\n          ...props.style,\n          ...markerStyle,\n        },\n      }\n    },\n    [isDisabled, isReversed, max, min, orientation, value, ids],\n  )\n\n  const getInputProps: RequiredPropGetter<{ index: number }> = useCallback(\n    (props, ref = null) => {\n      const { index, ...rest } = props\n      return {\n        ...rest,\n        ref,\n        id: ids.getInput(index),\n        type: \"hidden\",\n        value: value[index],\n        name: Array.isArray(name) ? name[index] : `${name}-${index}`,\n      }\n    },\n    [name, value, ids],\n  )\n\n  const state: RangeSliderState = {\n    value,\n    isFocused,\n    isDragging,\n    getThumbPercent: (index: number) => thumbPercents[index],\n    getThumbMinValue: (index: number) => valueBounds[index].min,\n    getThumbMaxValue: (index: number) => valueBounds[index].max,\n  }\n\n  return {\n    state,\n    actions,\n    getRootProps,\n    getTrackProps,\n    getInnerTrackProps,\n    getThumbProps,\n    getMarkerProps,\n    getInputProps,\n    getOutputProps,\n  }\n}\n\nexport type UseRangeSliderReturn = ReturnType<typeof useRangeSlider>\n\nfunction getValueBounds(\n  arr: number[],\n  min: number,\n  max: number,\n  spacing: number,\n) {\n  return arr.map((v, i) => {\n    const _min = i === 0 ? min : arr[i - 1] + spacing\n    const _max = i === arr.length - 1 ? max : arr[i + 1] - spacing\n    return { min: _min, max: _max }\n  })\n}\n"],"mappings":"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","names":["step","value","props"]}