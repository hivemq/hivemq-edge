import { promises } from 'node:fs';
import { defaults } from '@istanbuljs/schema';
import createDebug from 'debug';
import libCoverage from 'istanbul-lib-coverage';
import { createInstrumenter } from 'istanbul-lib-instrument';
import libReport from 'istanbul-lib-report';
import libSourceMaps from 'istanbul-lib-source-maps';
import reports from 'istanbul-reports';
import { parseModule } from 'magicast';
import TestExclude from 'test-exclude';
import c from 'tinyrainbow';
import { BaseCoverageProvider } from 'vitest/coverage';
import { C as COVERAGE_STORE_KEY } from './constants-BCJfMgEg.js';

const _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
function normalizeWindowsPath(input = "") {
  if (!input) {
    return input;
  }
  return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());
}
const _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
function cwd() {
  if (typeof process !== "undefined" && typeof process.cwd === "function") {
    return process.cwd().replace(/\\/g, "/");
  }
  return "/";
}
const resolve = function(...arguments_) {
  arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {
    const path = index >= 0 ? arguments_[index] : cwd();
    if (!path || path.length === 0) {
      continue;
    }
    resolvedPath = `${path}/${resolvedPath}`;
    resolvedAbsolute = isAbsolute(path);
  }
  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute && !isAbsolute(resolvedPath)) {
    return `/${resolvedPath}`;
  }
  return resolvedPath.length > 0 ? resolvedPath : ".";
};
function normalizeString(path, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let char = null;
  for (let index = 0; index <= path.length; ++index) {
    if (index < path.length) {
      char = path[index];
    } else if (char === "/") {
      break;
    } else {
      char = "/";
    }
    if (char === "/") {
      if (lastSlash === index - 1 || dots === 1) ; else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
            }
            lastSlash = index;
            dots = 0;
            continue;
          } else if (res.length > 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = index;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path.slice(lastSlash + 1, index)}`;
        } else {
          res = path.slice(lastSlash + 1, index);
        }
        lastSegmentLength = index - lastSlash - 1;
      }
      lastSlash = index;
      dots = 0;
    } else if (char === "." && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
const isAbsolute = function(p) {
  return _IS_ABSOLUTE_RE.test(p);
};

var version = "3.0.5";

const debug = createDebug("vitest:coverage");
class IstanbulCoverageProvider extends BaseCoverageProvider {
  name = "istanbul";
  version = version;
  instrumenter;
  testExclude;
  initialize(ctx) {
    this._initialize(ctx);
    this.testExclude = new TestExclude({
      cwd: ctx.config.root,
      include: this.options.include,
      exclude: this.options.exclude,
      excludeNodeModules: true,
      extension: this.options.extension,
      relativePath: !this.options.allowExternal
    });
    this.instrumenter = createInstrumenter({
      produceSourceMap: true,
      autoWrap: false,
      esModules: true,
      compact: false,
      coverageVariable: COVERAGE_STORE_KEY,
      // @ts-expect-error missing type
      coverageGlobalScope: "globalThis",
      coverageGlobalScopeFunc: false,
      ignoreClassMethods: this.options.ignoreClassMethods,
      parserPlugins: [
        ...defaults.instrumenter.parserPlugins,
        ["importAttributes", { deprecatedAssertSyntax: true }]
      ],
      generatorOpts: {
        importAttributesKeyword: "with"
      }
    });
  }
  onFileTransform(sourceCode, id, pluginCtx) {
    if (!this.testExclude.shouldInstrument(id)) {
      return;
    }
    const sourceMap = pluginCtx.getCombinedSourcemap();
    sourceMap.sources = sourceMap.sources.map(removeQueryParameters);
    sourceCode = sourceCode.replaceAll(
      "_ts_decorate",
      "/* istanbul ignore next */_ts_decorate"
    );
    const code = this.instrumenter.instrumentSync(
      sourceCode,
      id,
      sourceMap
    );
    const map = this.instrumenter.lastSourceMap();
    return { code, map };
  }
  createCoverageMap() {
    return libCoverage.createCoverageMap({});
  }
  async generateCoverage({ allTestsRun }) {
    const coverageMap = this.createCoverageMap();
    let coverageMapByTransformMode = this.createCoverageMap();
    await this.readCoverageFiles({
      onFileRead(coverage) {
        coverageMapByTransformMode.merge(coverage);
      },
      onFinished: async () => {
        const transformedCoverage = await transformCoverage(coverageMapByTransformMode);
        coverageMap.merge(transformedCoverage);
        coverageMapByTransformMode = this.createCoverageMap();
      },
      onDebug: debug
    });
    if (this.options.all && (allTestsRun || !this.options.cleanOnRerun)) {
      const coveredFiles = coverageMap.files();
      const uncoveredCoverage = await this.getCoverageMapForUncoveredFiles(coveredFiles);
      coverageMap.merge(await transformCoverage(uncoveredCoverage));
    }
    if (this.options.excludeAfterRemap) {
      coverageMap.filter((filename) => this.testExclude.shouldInstrument(filename));
    }
    return coverageMap;
  }
  async generateReports(coverageMap, allTestsRun) {
    const context = libReport.createContext({
      dir: this.options.reportsDirectory,
      coverageMap,
      watermarks: this.options.watermarks
    });
    if (this.hasTerminalReporter(this.options.reporter)) {
      this.ctx.logger.log(
        c.blue(" % ") + c.dim("Coverage report from ") + c.yellow(this.name)
      );
    }
    for (const reporter of this.options.reporter) {
      reports.create(reporter[0], {
        skipFull: this.options.skipFull,
        projectRoot: this.ctx.config.root,
        ...reporter[1]
      }).execute(context);
    }
    if (this.options.thresholds) {
      await this.reportThresholds(coverageMap, allTestsRun);
    }
  }
  async parseConfigModule(configFilePath) {
    return parseModule(
      await promises.readFile(configFilePath, "utf8")
    );
  }
  async getCoverageMapForUncoveredFiles(coveredFiles) {
    const allFiles = await this.testExclude.glob(this.ctx.config.root);
    let includedFiles = allFiles.map(
      (file) => resolve(this.ctx.config.root, file)
    );
    if (this.ctx.config.changed) {
      includedFiles = (this.ctx.config.related || []).filter(
        (file) => includedFiles.includes(file)
      );
    }
    const uncoveredFiles = includedFiles.filter((file) => !coveredFiles.includes(file)).sort();
    const cacheKey = (/* @__PURE__ */ new Date()).getTime();
    const coverageMap = this.createCoverageMap();
    const transform = this.createUncoveredFileTransformer(this.ctx);
    for (const [index, filename] of uncoveredFiles.entries()) {
      debug("Uncovered file %s %d/%d", filename, index, uncoveredFiles.length);
      await transform(`${filename}?v=${cacheKey}`);
      const lastCoverage = this.instrumenter.lastFileCoverage();
      coverageMap.addFileCoverage(lastCoverage);
    }
    return coverageMap;
  }
}
async function transformCoverage(coverageMap) {
  const sourceMapStore = libSourceMaps.createSourceMapStore();
  return await sourceMapStore.transformCoverage(coverageMap);
}
function removeQueryParameters(filename) {
  return filename.split("?")[0];
}

export { IstanbulCoverageProvider };
