name: CI Check

on:
  push:
    branches:
      - main
      - master
  pull_request:
  workflow_dispatch:

env:
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  # For frontend usage; secrets cannot be accessed in a conditional job
  SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
  PERCY_TOKEN: ${{ secrets.PERCY_TOKEN }}

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  # Note: check-frontend and check-backend use `if: always() &&` to ensure they
  # evaluate their conditions even when check-openapi is skipped.
  # Without this, GitHub Actions would skip them when any dependency is skipped.
  check-for-changes:
    runs-on: ubuntu-latest
    outputs:
      frontend-changed: ${{ steps.frontend.outputs.changed }}
      backend-changed: ${{ steps.backend.outputs.changed }}
      openapi-changed: ${{ steps.openapi.outputs.changed }}
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
        with:
          fetch-depth: 0
          
      - name: Check for backend changes
        uses: dorny/paths-filter@de90cc6fb38fc0963ad72b210f1f284cd68cea36 # v3.0.2
        id: backend
        with:
          filters: |
            changed:
              - 'hivemq-edge/**'
              - 'edge-plugins/**'
              - 'docker/**'
              - 'modules/**'
              - '.github/**'

      - name: Check for frontend changes
        uses: dorny/paths-filter@de90cc6fb38fc0963ad72b210f1f284cd68cea36 # v3.0.2
        id: frontend
        with:
          filters: |
            changed:
              - 'hivemq-edge-frontend/**'
              - '.github/**'

      - name: Check for openAPI changes
        uses: dorny/paths-filter@de90cc6fb38fc0963ad72b210f1f284cd68cea36 # v3.0.2
        id: openapi
        with:
          filters: |
            changed:
              - 'hivemq-edge-openapi/**'
              - '.github/**'

      - name: Debug changed output
        run: |
          echo "frontend-changed: ${{ steps.frontend.outputs.changed }}"
          echo "backend-changed: ${{ steps.backend.outputs.changed }}"
          echo "openapi-changed: ${{ steps.openapi.outputs.changed }}"


  check-openapi:
    needs: check-for-changes
    uses: ./.github/workflows/check-openapi.yml
    if: needs.check-for-changes.outputs.openapi-changed == 'true'

  # NOTE: check-frontend and check-backend currently depend on check-openapi for ordering only.
  # If OpenAPI artifacts are required for frontend/backend builds, consider:
  # 1. Making check-openapi run when ANY changes are detected (not just openapi changes)
  # 2. Using check-openapi.result != 'failure' in the conditions below
  # Current approach: Use `if: always() &&` to evaluate conditions independently of check-openapi status
  check-frontend:
    needs: [ check-for-changes, check-openapi ]
    uses: ./.github/workflows/check-frontend.yml
    # Always evaluate condition even if check-openapi was skipped
    if: always() && needs.check-for-changes.outputs.frontend-changed == 'true'
    secrets:
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      PERCY_TOKEN: ${{ secrets.PERCY_TOKEN }}

  check-backend:
    needs: [ check-for-changes, check-openapi ]
    uses: ./.github/workflows/check-backend.yml
    # Always evaluate condition even if check-openapi was skipped
    if: always() && needs.check-for-changes.outputs.backend-changed == 'true'


  check:
    runs-on: ubuntu-latest
    needs: [check-for-changes, check-openapi, check-frontend, check-backend]
    if: always()
    steps:
      - name: Check if openapi job succeeded
        if: needs.check-for-changes.outputs.openapi-changed == 'true'
        run: |
          if [[ ! "${{ needs.check-openapi.result }}" =~ ^(success|skipped)$ ]]; then
            echo "OpenAPI check failed"
            exit 1
          fi

      - name: Check if frontend job succeeded
        if: needs.check-for-changes.outputs.frontend-changed == 'true'
        # Continue on error, to deal with known blocks (percy tokens, sonarcloud gates)
        continue-on-error: true
        run: |
          if [[ ! "${{ needs.check-frontend.result }}" =~ ^(success|skipped)$ ]]; then
            echo "Frontend check failed"
            exit 1
          fi
      
      - name: Check if backend job succeeded
        if: needs.check-for-changes.outputs.backend-changed == 'true'
        run: |
          if [[ ! "${{ needs.check-backend.result }}" =~ ^(success|skipped)$ ]]; then
            echo "Backend check failed"
            exit 1
          fi
      
      - name: All checks passed
        run: echo "All required checks passed successfully!"
