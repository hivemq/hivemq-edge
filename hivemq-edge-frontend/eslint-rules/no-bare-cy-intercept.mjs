/**
 * ESLint rule: no-bare-cy-intercept
 *
 * Warns when cy.intercept() is used with an /api/ URL and a static response body.
 * Static intercepts should use cy.interceptApi(API_ROUTES.x.y, response) instead,
 * which enforces the response shape against the OpenAPI model at compile time.
 *
 * Callback-based intercepts (req handlers) are excluded — they handle stateful
 * scenarios (CRUD, dynamic replies) where cy.interceptApi does not apply.
 *
 * When the URL + HTTP method can be resolved to a known API_ROUTES entry, the rule
 * also provides an ESLint suggestion that rewrites the call automatically and injects
 * the API_ROUTES import if it is not already present.
 *
 * @see {@link cypress/support/__generated__/apiRoutes.ts} for the typed route registry
 * @see {@link https://linear.app/hivemq/issue/EDG-73}
 */

import { readFileSync } from 'node:fs'
import { dirname, join } from 'node:path'
import { fileURLToPath } from 'node:url'

const __dirname = dirname(fileURLToPath(import.meta.url))

const HTTP_METHODS = new Set(['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS'])

const API_ROUTES_IMPORT = "import { API_ROUTES } from '@cypr/support/__generated__/apiRoutes'\n"

// ─── Route map (lazy-loaded from generated meta) ──────────────────────────────

/** @type {Map<string, string> | null} */
let _routeMap = null

/**
 * Lazy-loads the "METHOD /url" → "API_ROUTES.namespace.method" reverse-lookup map
 * generated by tools/generateInterceptRoutes.ts alongside apiRoutes.ts.
 *
 * Returns an empty map if the file is not yet generated, so the rule degrades
 * gracefully to warnings-only (no suggestions) before the first codegen run.
 *
 * @returns {Map<string, string>}
 */
function getRouteMap() {
  if (_routeMap !== null) return _routeMap
  try {
    const metaPath = join(__dirname, '..', 'cypress/support/__generated__/apiRoutes.meta.json')
    _routeMap = new Map(Object.entries(JSON.parse(readFileSync(metaPath, 'utf-8'))))
  } catch {
    _routeMap = new Map()
  }
  return _routeMap
}

// ─── Helpers ──────────────────────────────────────────────────────────────────

/** Returns true if the file already imports API_ROUTES from the generated registry. */
function hasApiRoutesImport(sourceCode) {
  return sourceCode.ast.body.some(
    (node) =>
      node.type === 'ImportDeclaration' &&
      node.specifiers.some((spec) => spec.local.name === 'API_ROUTES')
  )
}

/**
 * Builds a single suggest entry for a known routeKey.
 *
 * The fix function:
 *   1. Replaces the cy.intercept(...) call with cy.interceptApi(routeKey, body)
 *   2. Prepends the API_ROUTES import if the file does not already have one
 *
 * @param {string} routeKey      e.g. "API_ROUTES.bridges.getBridges"
 * @param {object} node          the cy.intercept CallExpression AST node
 * @param {object|null} bodyArg  the response body argument node, or null
 * @param {object} sourceCode    ESLint SourceCode object
 */
function makeSuggest(routeKey, node, bodyArg, sourceCode) {
  return {
    messageId: 'suggestInterceptApi',
    data: { routeKey },
    fix(fixer) {
      const fixes = []
      const bodyText = bodyArg ? `, ${sourceCode.getText(bodyArg)}` : ''
      fixes.push(fixer.replaceText(node, `cy.interceptApi(${routeKey}${bodyText})`))
      if (!hasApiRoutesImport(sourceCode)) {
        fixes.push(fixer.insertTextBefore(sourceCode.ast.body[0], API_ROUTES_IMPORT))
      }
      return fixes
    },
  }
}

// ─── Rule ─────────────────────────────────────────────────────────────────────

/** @type {import('eslint').Rule.RuleModule} */
export const noBareIntercept = {
  meta: {
    type: 'suggestion',
    docs: {
      description: 'Enforce cy.interceptApi() instead of cy.intercept() for static /api/ responses',
      recommended: false,
      url: 'https://linear.app/hivemq/issue/EDG-73',
    },
    hasSuggestions: true,
    messages: {
      useInterceptApi:
        'Use cy.interceptApi(API_ROUTES.namespace.route, response) instead of cy.intercept() for static API responses.' +
        ' See cypress/support/__generated__/apiRoutes.ts for the typed route registry.',
      suggestInterceptApi: 'Replace with cy.interceptApi({{routeKey}}, ...)',
    },
    schema: [],
  },

  create(context) {
    const sourceCode = context.sourceCode
    const routeMap = getRouteMap()

    return {
      CallExpression(node) {
        // Match only cy.intercept(...)
        if (
          node.callee.type !== 'MemberExpression' ||
          node.callee.object.type !== 'Identifier' ||
          node.callee.object.name !== 'cy' ||
          node.callee.property.type !== 'Identifier' ||
          node.callee.property.name !== 'intercept'
        ) {
          return
        }

        const args = node.arguments
        if (args.length === 0) return

        // Exclude callback-based intercepts — any argument that is a function
        // expression signals a req handler (stateful/CRUD) which stays as cy.intercept
        const hasCallback = args.some(
          (arg) => arg.type === 'ArrowFunctionExpression' || arg.type === 'FunctionExpression'
        )
        if (hasCallback) return

        // cy.intercept('/api/...', ...) — URL-only or URL+response
        // No HTTP method available, so try all methods and offer a suggestion for each match.
        const firstArg = args[0]
        if (firstArg.type === 'Literal' && typeof firstArg.value === 'string' && firstArg.value.startsWith('/api/')) {
          const url = firstArg.value
          const bodyArg = args[1] ?? null
          const suggest = [...HTTP_METHODS]
            .map((method) => routeMap.get(`${method} ${url}`))
            .filter(Boolean)
            .map((routeKey) => makeSuggest(routeKey, node, bodyArg, sourceCode))
          context.report({ node, messageId: 'useInterceptApi', suggest })
          return
        }

        // cy.intercept('GET', '/api/...', ...) — method + URL + optional response
        if (
          args.length >= 2 &&
          firstArg.type === 'Literal' &&
          typeof firstArg.value === 'string' &&
          HTTP_METHODS.has(firstArg.value.toUpperCase())
        ) {
          const secondArg = args[1]
          if (
            secondArg.type === 'Literal' &&
            typeof secondArg.value === 'string' &&
            secondArg.value.startsWith('/api/')
          ) {
            const routeKey = routeMap.get(`${firstArg.value.toUpperCase()} ${secondArg.value}`)
            const bodyArg = args[2] ?? null
            const suggest = routeKey ? [makeSuggest(routeKey, node, bodyArg, sourceCode)] : []
            context.report({ node, messageId: 'useInterceptApi', suggest })
          }
        }
      },
    }
  },
}
