/**
 * ESLint rule: no-bare-cy-intercept
 *
 * Warns when cy.intercept() is used with an /api/ URL and a static response body.
 * Static intercepts should use cy.interceptApi(API_ROUTES.x.y, response) instead,
 * which enforces the response shape against the OpenAPI model at compile time.
 *
 * Callback-based intercepts (req handlers) are excluded — they handle stateful
 * scenarios (CRUD, dynamic replies) where cy.interceptApi does not apply.
 *
 * Three categories of diagnostic:
 *
 *   1. useInterceptApi — URL starts with /api/ and matches (or is close to) a known
 *      route. Offers an exact suggestion or a Levenshtein-based "did you mean" fix.
 *
 *   2. missingLeadingSlash — URL starts with api/ (no leading slash). Almost always
 *      a typo. Normalised URL is looked up for an exact or fuzzy suggestion.
 *
 * @see {@link cypress/support/__generated__/apiRoutes.ts} for the typed route registry
 * @see {@link https://linear.app/hivemq/issue/EDG-73}
 */

import { readFileSync } from 'node:fs'
import { dirname, join } from 'node:path'
import { fileURLToPath } from 'node:url'

const __dirname = dirname(fileURLToPath(import.meta.url))

const HTTP_METHODS = new Set(['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS'])

const API_ROUTES_IMPORT = "import { API_ROUTES } from '@cypr/support/__generated__/apiRoutes'\n"

/** Maximum edit distance for a fuzzy URL match to be offered as a suggestion. */
const LEVENSHTEIN_THRESHOLD = 3

// ─── Route map (lazy-loaded from generated meta) ──────────────────────────────

/** @type {Map<string, string> | null} */
let _routeMap = null

/**
 * Lazy-loads the "METHOD /url" → "API_ROUTES.namespace.method" reverse-lookup map
 * generated by tools/generateInterceptRoutes.ts alongside apiRoutes.ts.
 *
 * Returns an empty map if the file is not yet generated, so the rule degrades
 * gracefully to warnings-only (no suggestions) before the first codegen run.
 *
 * @returns {Map<string, string>}
 */
function getRouteMap() {
  if (_routeMap !== null) return _routeMap
  try {
    const metaPath = join(__dirname, '..', 'cypress/support/__generated__/apiRoutes.meta.json')
    _routeMap = new Map(Object.entries(JSON.parse(readFileSync(metaPath, 'utf-8'))))
  } catch {
    _routeMap = new Map()
  }
  return _routeMap
}

// ─── URL list (lazy-derived for Levenshtein search) ───────────────────────────

/** @type {Array<{method: string, url: string, routeKey: string}> | null} */
let _urlList = null

/**
 * Returns the route map entries decomposed into {method, url, routeKey} objects,
 * cached for the lifetime of the ESLint daemon session.
 */
function getUrlList() {
  if (_urlList !== null) return _urlList
  const routeMap = getRouteMap()
  _urlList = [...routeMap.entries()].map(([key, routeKey]) => {
    const spaceIdx = key.indexOf(' ')
    return { method: key.slice(0, spaceIdx), url: key.slice(spaceIdx + 1), routeKey }
  })
  return _urlList
}

// ─── Levenshtein ──────────────────────────────────────────────────────────────

/**
 * Computes the Levenshtein edit distance between two strings.
 * Uses two-row dynamic programming for O(min(m,n)) space.
 *
 * @param {string} a
 * @param {string} b
 * @returns {number}
 */
function levenshtein(a, b) {
  const m = a.length,
    n = b.length
  if (m === 0) return n
  if (n === 0) return m
  let prev = Array.from({ length: n + 1 }, (_, i) => i)
  let curr = new Array(n + 1)
  for (let i = 1; i <= m; i++) {
    curr[0] = i
    for (let j = 1; j <= n; j++) {
      curr[j] = a[i - 1] === b[j - 1] ? prev[j - 1] : 1 + Math.min(prev[j - 1], prev[j], curr[j - 1])
    }
    ;[prev, curr] = [curr, prev]
  }
  return prev[n]
}

/**
 * Finds routes within LEVENSHTEIN_THRESHOLD edit distance of `url`.
 * Optionally restricts results to a specific HTTP method.
 * Returns up to 2 results sorted by ascending distance.
 *
 * @param {string} url
 * @param {string|null} method  restrict to this HTTP method, or null for all
 * @returns {Array<{routeKey: string, distance: number}>}
 */
function findClosestRoutes(url, method = null) {
  const results = []
  for (const entry of getUrlList()) {
    if (method && entry.method !== method) continue
    const dist = levenshtein(url, entry.url)
    if (dist > 0 && dist <= LEVENSHTEIN_THRESHOLD) {
      results.push({ routeKey: entry.routeKey, distance: dist })
    }
  }
  return results.sort((a, b) => a.distance - b.distance).slice(0, 2)
}

// ─── Helpers ──────────────────────────────────────────────────────────────────

/** Returns true if the file already imports API_ROUTES from the generated registry. */
function hasApiRoutesImport(sourceCode) {
  return sourceCode.ast.body.some(
    (node) => node.type === 'ImportDeclaration' && node.specifiers.some((spec) => spec.local.name === 'API_ROUTES')
  )
}

/**
 * Builds a suggest entry for a confirmed exact route match.
 *
 * @param {string} routeKey      e.g. "API_ROUTES.bridges.getBridges"
 * @param {object} node          the cy.intercept CallExpression AST node
 * @param {object|null} bodyArg  the response body argument node, or null
 * @param {object} sourceCode    ESLint SourceCode object
 */
function makeSuggest(routeKey, node, bodyArg, sourceCode) {
  return {
    messageId: 'suggestInterceptApi',
    data: { routeKey },
    fix(fixer) {
      const fixes = []
      const bodyText = bodyArg ? `, ${sourceCode.getText(bodyArg)}` : ''
      fixes.push(fixer.replaceText(node, `cy.interceptApi(${routeKey}${bodyText})`))
      if (!hasApiRoutesImport(sourceCode)) {
        fixes.push(fixer.insertTextBefore(sourceCode.ast.body[0], API_ROUTES_IMPORT))
      }
      return fixes
    },
  }
}

/**
 * Builds a suggest entry for a fuzzy (Levenshtein) route match.
 * The description includes the edit distance to signal it is a best guess.
 *
 * @param {string} routeKey
 * @param {number} distance  Levenshtein edit distance
 * @param {object} node
 * @param {object|null} bodyArg
 * @param {object} sourceCode
 */
function makeSuggestTypo(routeKey, distance, node, bodyArg, sourceCode) {
  return {
    messageId: 'suggestTypoFix',
    data: { routeKey, distance },
    fix(fixer) {
      const fixes = []
      const bodyText = bodyArg ? `, ${sourceCode.getText(bodyArg)}` : ''
      fixes.push(fixer.replaceText(node, `cy.interceptApi(${routeKey}${bodyText})`))
      if (!hasApiRoutesImport(sourceCode)) {
        fixes.push(fixer.insertTextBefore(sourceCode.ast.body[0], API_ROUTES_IMPORT))
      }
      return fixes
    },
  }
}

/**
 * Builds the suggest array for a URL: exact matches first, Levenshtein fallback.
 *
 * @param {string} url          normalised URL starting with /api/
 * @param {string|null} method  if known, restrict exact + fuzzy search to this method
 * @param {object} node
 * @param {object|null} bodyArg
 * @param {object} sourceCode
 * @param {Map<string,string>} routeMap
 */
function buildSuggest(url, method, node, bodyArg, sourceCode, routeMap) {
  // Exact matches (all methods if method is null, otherwise just the one)
  const methods = method ? [method] : [...HTTP_METHODS]
  const exactSuggests = methods
    .map((m) => routeMap.get(`${m} ${url}`))
    .filter(Boolean)
    .map((routeKey) => makeSuggest(routeKey, node, bodyArg, sourceCode))

  if (exactSuggests.length > 0) return exactSuggests

  // Levenshtein fallback
  return findClosestRoutes(url, method).map(({ routeKey, distance }) =>
    makeSuggestTypo(routeKey, distance, node, bodyArg, sourceCode)
  )
}

// ─── Rule ─────────────────────────────────────────────────────────────────────

/** @type {import('eslint').Rule.RuleModule} */
export const noBareIntercept = {
  meta: {
    type: 'suggestion',
    docs: {
      description: 'Enforce cy.interceptApi() instead of cy.intercept() for static /api/ responses',
      recommended: false,
      url: 'https://linear.app/hivemq/issue/EDG-73',
    },
    hasSuggestions: true,
    messages: {
      useInterceptApi:
        'Use cy.interceptApi(API_ROUTES.namespace.route, response) instead of cy.intercept() for static API responses.' +
        ' See cypress/support/__generated__/apiRoutes.ts for the typed route registry.',
      suggestInterceptApi: 'Replace with cy.interceptApi({{routeKey}}, ...)',
      missingLeadingSlash:
        '"{{url}}" looks like an API route but is missing a leading slash — did you mean \'/{{url}}\'?',
      suggestTypoFix: 'Replace with cy.interceptApi({{routeKey}}, ...) — closest match (edit distance: {{distance}})',
    },
    schema: [],
  },

  create(context) {
    const sourceCode = context.sourceCode
    const routeMap = getRouteMap()

    return {
      CallExpression(node) {
        // Match only cy.intercept(...)
        if (
          node.callee.type !== 'MemberExpression' ||
          node.callee.object.type !== 'Identifier' ||
          node.callee.object.name !== 'cy' ||
          node.callee.property.type !== 'Identifier' ||
          node.callee.property.name !== 'intercept'
        ) {
          return
        }

        const args = node.arguments
        if (args.length === 0) return

        // Exclude callback-based intercepts — any argument that is a function
        // expression signals a req handler (stateful/CRUD) which stays as cy.intercept
        const hasCallback = args.some(
          (arg) => arg.type === 'ArrowFunctionExpression' || arg.type === 'FunctionExpression'
        )
        if (hasCallback) return

        const firstArg = args[0]
        if (firstArg.type !== 'Literal' || typeof firstArg.value !== 'string') return

        const firstVal = firstArg.value

        // ── cy.intercept('api/...') or cy.intercept('api/...', body) ──────────
        // URL-only, missing leading slash.
        if (firstVal.startsWith('api/')) {
          const bodyArg = args[1] ?? null
          const normalizedUrl = '/' + firstVal
          const suggest = buildSuggest(normalizedUrl, null, node, bodyArg, sourceCode, routeMap)
          context.report({ node, messageId: 'missingLeadingSlash', data: { url: firstVal }, suggest })
          return
        }

        // ── cy.intercept('/api/...') or cy.intercept('/api/...', body) ────────
        // URL-only, correct leading slash.
        if (firstVal.startsWith('/api/')) {
          const bodyArg = args[1] ?? null
          const suggest = buildSuggest(firstVal, null, node, bodyArg, sourceCode, routeMap)
          context.report({ node, messageId: 'useInterceptApi', suggest })
          return
        }

        // ── cy.intercept('METHOD', url, ...) ──────────────────────────────────
        if (args.length >= 2 && HTTP_METHODS.has(firstVal.toUpperCase())) {
          const secondArg = args[1]
          if (secondArg.type !== 'Literal' || typeof secondArg.value !== 'string') return

          const method = firstVal.toUpperCase()
          const url = secondArg.value
          const bodyArg = args[2] ?? null

          if (url.startsWith('api/')) {
            const normalizedUrl = '/' + url
            const suggest = buildSuggest(normalizedUrl, method, node, bodyArg, sourceCode, routeMap)
            context.report({ node, messageId: 'missingLeadingSlash', data: { url }, suggest })
            return
          }

          if (url.startsWith('/api/')) {
            const suggest = buildSuggest(url, method, node, bodyArg, sourceCode, routeMap)
            context.report({ node, messageId: 'useInterceptApi', suggest })
          }
        }
      },
    }
  },
}
