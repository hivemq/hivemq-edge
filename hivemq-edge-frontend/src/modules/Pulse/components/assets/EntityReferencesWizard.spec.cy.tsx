import type { AdaptersList, BridgeList } from '@/api/__generated__'
import { EntityType } from '@/api/__generated__'
import { mockBridge } from '@/api/hooks/useGetBridges/__handlers__'
import { mockAdapter, mockProtocolAdapter } from '@/api/hooks/useProtocolAdapters/__handlers__'
import EntityReferencesWizard from '@/modules/Pulse/components/assets/EntityReferencesWizard.tsx'
import { DEFAULT_ASSET_MAPPER_SOURCES } from '@/modules/Pulse/utils/assets.utils.ts'

const MOCK_BRIDGE_LIST: BridgeList = { items: [mockBridge] }
const MOCK_PROTOCOL_ADAPTER_LIST: AdaptersList = { items: [mockAdapter] }

// This was generated by Copilot and didn't meet minimum acceptance criteria
describe('EntityReferencesWizard', () => {
  beforeEach(() => {
    cy.viewport(800, 600)
    cy.intercept('/api/v1/management/bridges', { items: [mockBridge] }).as('getBridges')
    cy.intercept('/api/v1/management/bridges/*', mockBridge)

    cy.intercept('/api/v1/management/protocol-adapters/types', { items: [mockProtocolAdapter] })
    cy.intercept('/api/v1/management/protocol-adapters/adapters', { items: [mockAdapter] }).as('getAdapters')
  })

  it('should render properly with empty values', () => {
    const onChange = cy.stub().as('onChange')

    cy.mountWithProviders(<EntityReferencesWizard values={[]} onChange={onChange} />)

    cy.wait(['@getBridges', '@getAdapters'])

    cy.getByTestId('wizard-mapper-entities-container').within(() => {
      cy.get("label[for='mapper-sources']").should('contain.text', 'Data Sources')

      cy.get('#wizard-mapper-sources').should('have.text', 'Type or select ...')
      cy.get('#react-select-sources-helper').should(
        'have.text',
        'The data sources this new mapper will be initially connected to'
      )

      cy.get('#wizard-mapper-sources').should('be.visible')
      cy.get('#react-select-sources-placeholder').should('be.visible')
    })

    cy.get('@onChange').should('not.have.been.called')
  })

  it('should display more info popover', () => {
    cy.mountWithProviders(<EntityReferencesWizard values={[]} onChange={cy.stub} />)
    cy.wait(['@getBridges', '@getAdapters'])

    cy.getByTestId('wizard-mapper-entities-container').within(() => {
      cy.get("label[for='mapper-sources']").within(() => {
        cy.getByTestId('more-info-trigger').click()
        cy.get('[data-testid="more-info-popover"]')
          .should('be.visible')
          .should(
            'contain.text',
            'Data sources are the entities from the Workspace where integration points are collected from. Edge and the Pulse Agent will be added automatically.'
          )
        cy.getByTestId('more-info-trigger').click()
        cy.get('[data-testid="more-info-popover"]').should('not.be.visible')
      })
    })
  })

  it('should load and display options from bridges and adapters', () => {
    cy.mountWithProviders(<EntityReferencesWizard values={[]} onChange={cy.stub} />)
    cy.get('#wizard-mapper-sources').click()
    cy.wait(['@getBridges', '@getAdapters'])

    cy.get('#react-select-sources-listbox [role="listbox"]').within(() => {
      // Should have options from both bridges and adapters
      cy.get('[role="option"]').should('have.length.greaterThan', 0)

      // Verify bridge entities are present
      MOCK_BRIDGE_LIST.items.forEach((bridge) => {
        cy.contains(`[role="option"]`, bridge.id).should('have.text', bridge.id)
      })

      // Verify adapter entities are present
      MOCK_PROTOCOL_ADAPTER_LIST.items.forEach((adapter) => {
        cy.contains(`[role="option"]`, adapter.id)
          .should('contain.text', adapter.id)
          .should('contain.text', 'Simulated Edge Device')
      })
    })
  })

  it('should handle selecting and removing options', () => {
    const onChange = cy.stub().as('onChange')

    cy.mountWithProviders(<EntityReferencesWizard values={DEFAULT_ASSET_MAPPER_SOURCES} onChange={onChange} />)

    cy.wait(['@getBridges', '@getAdapters'])

    // Select first bridge option
    cy.get('#wizard-mapper-sources').click()
    cy.get('#react-select-sources-listbox [role="listbox"]').within(() => {
      cy.get('[role="option"]').eq(1).click()
    })

    cy.get('@onChange').should('have.been.calledWith', [
      {
        id: 'edge',
        type: 'EDGE_BROKER',
      },
      {
        id: 'idPulse',
        type: 'PULSE_AGENT',
      },
      {
        type: 'ADAPTER',
        id: 'my-adapter',
      },
    ])
  })

  it('should render with pre-selected values', () => {
    const preselectedValues = [
      { type: EntityType.BRIDGE, id: 'bridge-1' },
      { type: EntityType.ADAPTER, id: 'adapter-1' },
    ]

    cy.mountWithProviders(<EntityReferencesWizard values={preselectedValues} onChange={cy.stub} />)

    cy.wait(['@getBridges', '@getAdapters'])

    cy.getByTestId('multi-selected-value').should('have.length', 2)
    preselectedValues.forEach((value) => {
      cy.getByTestId('multi-selected-value').should('contain.text', value.id)
    })
  })

  it('should prevent removal of EDGE_BROKER and PULSE_AGENT entities', () => {
    const onChange = cy.stub()
    const valuesWithNonRemovable = [
      { type: EntityType.EDGE_BROKER, id: 'edge-broker-1' },
      { type: EntityType.PULSE_AGENT, id: 'pulse-agent-1' },
      { type: EntityType.BRIDGE, id: 'bridge-1' },
    ]

    cy.mountWithProviders(<EntityReferencesWizard values={valuesWithNonRemovable} onChange={onChange} />)

    cy.wait(['@getBridges', '@getAdapters'])

    cy.getByTestId('multi-selected-value').should('have.length', 3)
    cy.getByTestId('multi-selected-value')
      .eq(2)
      .within(() => {
        cy.get('[role="button"]').should('have.attr', 'aria-label', 'Remove bridge-1')
      })
    cy.getByTestId('multi-selected-value')
      .eq(0)
      .within(() => {
        cy.get('[role="button"]').should('not.exist')
      })
    cy.getByTestId('multi-selected-value')
      .eq(1)
      .within(() => {
        cy.get('[role="button"]').should('not.exist')
      })
  })

  it('should enforce minimum default sources when removing all selections', () => {
    const onChange = cy.stub().as('onChange')
    const initialValues = [{ type: EntityType.BRIDGE, id: 'bridge-1' }]

    cy.mountWithProviders(<EntityReferencesWizard values={initialValues} onChange={onChange} />)

    cy.wait(['@getBridges', '@getAdapters']).then(() => {
      // Clear all selections
      cy.get('#wizard-mapper-sources').within(() => {
        cy.getByAriaLabel('Clear selected options').click()
      })
    })

    // Should call onChange with default sources when attempting to go below minimum
    cy.get('@onChange').should('have.been.called')
  })

  it('should filter options based on search input', () => {
    cy.mountWithProviders(<EntityReferencesWizard values={[]} onChange={cy.stub} />)

    cy.wait(['@getBridges', '@getAdapters'])

    cy.get('#wizard-mapper-sources').click()
    cy.get('#wizard-mapper-sources input').type('bridge')

    cy.get('#react-select-sources-listbox [role="listbox"]').within(() => {
      cy.get('[role="option"]').each(($option) => {
        cy.wrap($option).should('contain.text', 'bridge')
      })
    })
  })

  it('should display no options message when no matches found', () => {
    cy.mountWithProviders(<EntityReferencesWizard values={[]} onChange={cy.stub} />)

    cy.wait(['@getBridges', '@getAdapters'])

    cy.get('#wizard-mapper-sources').click()
    cy.get('#wizard-mapper-sources input').type('nonexistent')

    cy.get('#react-select-sources-listbox').should('contain.text', 'No entities matching the filter')
  })

  it('should display no options available when input is empty and no options exist', () => {
    cy.intercept('/api/v1/management/bridges', { items: [] })
    cy.intercept('/api/v1/management/protocol-adapters/adapters', { items: [] })

    cy.mountWithProviders(<EntityReferencesWizard values={[]} onChange={cy.stub} />)

    cy.get('#wizard-mapper-sources').click()

    cy.get('#react-select-sources-listbox').should('contain.text', 'No entities available')
  })

  it('should handle bridge loading error', () => {
    cy.intercept('/api/v1/management/protocol-adapters/adapters', { statusCode: 404 })

    cy.mountWithProviders(<EntityReferencesWizard values={[]} onChange={cy.stub} />)

    cy.get('[role="alert"]').should('have.attr', 'data-status', 'error').should('contain.text', 'Not Found')
  })

  it('should handle adapter loading error', () => {
    cy.intercept('/api/v1/management/bridges', { statusCode: 404 })

    cy.mountWithProviders(<EntityReferencesWizard values={[]} onChange={cy.stub} />)

    cy.get('[role="alert"]').should('have.attr', 'data-status', 'error').should('contain.text', 'Not Found')
  })

  it.skip('should show loading state while fetching data', () => {
    cy.intercept('/api/v1/management/bridges', { delay: 1000, body: MOCK_BRIDGE_LIST })
    cy.intercept('/api/v1/management/protocol-adapters', { delay: 1000, body: MOCK_PROTOCOL_ADAPTER_LIST })

    cy.mountWithProviders(<EntityReferencesWizard values={[]} onChange={cy.stub} />)

    cy.get('#wizard-mapper-sources').should('have.attr', 'aria-busy', 'true')
  })

  it('should be accessible', () => {
    cy.injectAxe()
    cy.mountWithProviders(<EntityReferencesWizard values={[]} onChange={cy.stub} />)

    cy.wait(['@getBridges', '@getAdapters'])

    cy.get('#wizard-mapper-sources').click()
    cy.checkAccessibility(undefined, {
      rules: {
        // ReactSelect may have aria-input-field-name issues
        'aria-input-field-name': { enabled: false },
      },
    })
  })
})
