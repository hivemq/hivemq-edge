---
title: "Type-Safe Cypress Intercepts"
author: "Edge Frontend Team"
last_updated: "2026-02-19"
purpose: "Documents the cy.interceptApi() command, API_ROUTES registry, ESLint enforcement, and IDE integration"
audience: "Developers writing Cypress tests"
maintained_at: "docs/api/CYPRESS_INTERCEPT_API.md"
---


# Type-Safe Cypress Intercepts

---

## Table of Contents

- [Overview](#overview)
- [The API\_ROUTES Registry](#the-api_routes-registry)
- [cy.interceptApi() Command](#cyinterceptapi-command)
- [Parametric Routes](#parametric-routes)
- [ESLint Enforcement](#eslint-enforcement)
- [IDE Integration](#ide-integration)
- [When to Still Use cy.intercept()](#when-to-still-use-cyintercept)
- [Related Documentation](#related-documentation)

---

## Overview

`cy.interceptApi()` is a typed wrapper around Cypress's built-in `cy.intercept()` that enforces
response shapes against the OpenAPI model at the call site.

**Why it exists:**

```typescript
// ❌ Before — no type safety, wrong shape goes unnoticed until runtime
cy.intercept('GET', '/api/v1/management/bridges', { bridges: [] })

// ✅ After — TypeScript error: 'bridges' does not exist on type 'BridgeList'
cy.interceptApi(API_ROUTES.bridges.getBridges, { bridges: [] })
```

The `API_ROUTES` registry and the `cy.interceptApi()` command are both fully generated from the
OpenAPI spec, so they stay in sync automatically every time the API client is regenerated.

---

## The API\_ROUTES Registry

### Location and generation

```
cypress/support/__generated__/apiRoutes.ts   ← typed registry (do not edit)
cypress/support/__generated__/apiRoutes.meta.json  ← ESLint reverse-lookup map (do not edit)
```

Both files are generated by `tools/generateInterceptRoutes.ts`, which runs automatically at the end
of `pnpm dev:openAPI`.

### Structure

Namespaces mirror the `HiveMqClient` service structure:

```typescript
export const API_ROUTES = {
  bridges: {
    getBridges:     route<BridgeList>('GET',    '/api/v1/management/bridges'),
    addBridge:      route<void>('POST',         '/api/v1/management/bridges'),
    getBridgeByName: routeWithParams<Bridge>()('GET', '/api/v1/management/bridges/{bridgeId}'),
    removeBridge:   routeWithParams<void>()('DELETE', '/api/v1/management/bridges/{bridgeId}'),
    // ...
  },
  protocolAdapters: { /* ... */ },
  frontend:         { /* ... */ },
  // 24 namespaces total, 114 routes
} as const
```

Go-to-definition on any route opens the registry entry, which carries a `@see` JSDoc link to the
originating service class and method.

---

## cy.interceptApi() Command

### Basic usage

```typescript
import { API_ROUTES } from '@cypr/support/__generated__/apiRoutes'

// TypeScript validates the response shape against BridgeList
cy.interceptApi(API_ROUTES.bridges.getBridges, { items: [mockBridge] })

// Status-only shorthand (no body validation — useful for disabling polling)
cy.interceptApi(API_ROUTES.protocolAdapters.getAdaptersStatus, { statusCode: 202, log: false })

// Alias for cy.wait()
cy.interceptApi(API_ROUTES.bridges.getBridges, { items: [] }).as('getBridges')
cy.wait('@getBridges')

// Routing options with a typed body (delay, headers, etc.)
cy.interceptApi(API_ROUTES.bridges.getBridges, {
  body: { items: [mockBridge] },
  delay: 500,
})
```

### Command signature

```typescript
cy.interceptApi(route: Route<T>, response: T | StaticResponse<T>): Chainable
```

Where `Route<T>` carries `T` as a phantom type parameter — it never exists at runtime but is
inferred by TypeScript to constrain the `response` argument.

`StaticResponse<T>` is the typed envelope for Cypress routing options:

```typescript
type StaticResponse<T> = {
  body?: T                                    // typed body — validated against the OpenAPI model
  statusCode?: number
  headers?: Record<string, string | string[]>
  delay?: number
  throttleKbps?: number
  forceNetworkError?: boolean
  log?: boolean
}
```

Pass the response body directly when only a body is needed (`T`). Use `StaticResponse<T>` when
you also need routing options such as `delay` or custom `headers`.

### In beforeEach

```typescript
beforeEach(() => {
  cy_interceptCoreE2E()  // sets up auth, config, and common polling stubs

  cy.interceptApi(API_ROUTES.bridges.getBridges, { items: [mockBridge] }).as('getBridges')
  loginPage.visit('/app/bridges')
  loginPage.loginButton.click()
  cy.wait('@getBridges')
})
```

**Location:** `cypress/support/commands/interceptApi.ts`

---

## Parametric Routes

Routes with path parameters produce a `ParametricRoute<T, Template>` instead of a plain `Route<T>`.
They work in two modes:

### Default — wildcard match

Used without calling `.withParams()`, the route URL contains `**` wildcards and matches any value
for each parameter. This is the default and covers most test scenarios:

```typescript
// Matches GET /api/v1/management/bridges/<anything>
cy.interceptApi(API_ROUTES.bridges.getBridgeByName, { id: 'my-bridge', /* ... */ })
```

### Explicit — resolve to specific ID

Use `.withParams()` to intercept a single specific resource and let other IDs pass through:

```typescript
// Matches only GET /api/v1/management/bridges/my-bridge
cy.interceptApi(
  API_ROUTES.bridges.getBridgeByName.withParams({ bridgeId: 'my-bridge' }),
  { id: 'my-bridge', /* ... */ }
)
```

TypeScript infers the allowed parameter names from the URL template literal and flags typos:

```typescript
// ❌ TypeScript error — 'id' is not a valid param, expected 'bridgeId'
API_ROUTES.bridges.getBridgeByName.withParams({ id: 'my-bridge' })
```

---

## ESLint Enforcement

### Rule: `local/no-bare-cy-intercept`

The custom rule `no-bare-cy-intercept` (in `eslint-rules/no-bare-cy-intercept.mjs`) produces three
categories of diagnostic for `cy.intercept()` calls that target API routes.

---

#### Diagnostic 1 — `useInterceptApi` (static `/api/` call)

Triggered when the URL starts with `/api/` and no callback handler is present:

```
warning  Use cy.interceptApi(API_ROUTES.namespace.route, response) instead of cy.intercept()
         for static API responses.  local/no-bare-cy-intercept
```

When the URL and method match a known registry entry, the IDE offers an inline quick-fix that
rewrites the call and injects the `API_ROUTES` import automatically (see [IDE Integration](#ide-integration)).

---

#### Diagnostic 2 — `missingLeadingSlash` (typo — missing `/`)

Triggered when the URL starts with `api/` (no leading slash), which is almost always a typo and
goes completely undetected by Cypress at runtime:

```typescript
// ❌ Not flagged by Cypress — silently matches nothing at all
cy.intercept('api/v1/management/bridges', { items: [] })
```

```
warning  "api/v1/management/bridges" looks like an API route but is missing a leading slash
         — did you mean '/api/v1/management/bridges'?  local/no-bare-cy-intercept
```

The rule normalises the URL (prepends `/`) and offers the same `cy.interceptApi()` quick-fix as
diagnostic 1 when a matching route is found.

---

#### Diagnostic 3 — `suggestTypoFix` (Levenshtein "did you mean")

When the URL starts with `/api/` but does not exactly match any known registry entry, the rule
computes the Levenshtein edit distance against every route in the registry. If a match is found
within `LEVENSHTEIN_THRESHOLD = 3` edits, the IDE offers a "closest match" suggestion:

```typescript
// URL has a subtle typo: "adaptors" vs "adapters"
cy.intercept('/api/v1/management/protocol-adaptors/types', { items: [] })
```

```
warning  Use cy.interceptApi(...) for static API responses.  local/no-bare-cy-intercept

  Suggestion: Replace with cy.interceptApi(API_ROUTES.protocolAdapters.getAdapterTypes, ...)
              — closest match (edit distance: 1)
```

Up to two suggestions are offered, sorted by ascending edit distance. A method filter is applied
when the call already includes an explicit HTTP method (e.g. `cy.intercept('GET', url, body)`).

---

**Excluded from all diagnostics:**

- Callback-based handlers `cy.intercept('GET', url, (req) => { ... })` — these handle
  stateful/CRUD scenarios that `cy.interceptApi()` does not cover
- Non-API URLs such as `https://api.github.com/...`

**CI behaviour:**

Warnings are visible in IDE and CLI output but do not fail the build (`--max-warnings 0` is not
enforced). This allows incremental migration without blocking development. The severity can be
escalated to `'error'` in `eslint.config.mjs` once migration is complete.

---

## IDE Integration

Both WebStorm and VS Code offer one-click migration via ESLint's suggestion mechanism. When the
URL and HTTP method in a bare `cy.intercept()` call can be resolved to a known `API_ROUTES` entry,
the IDE offers an inline action that rewrites the call and injects the import automatically.

### WebStorm

1. Place the caret on the underlined warning
2. Press **Alt+Enter** (Show Intention Actions)
3. Select **"Apply ESLint Suggestion: Replace with cy.interceptApi(API\_ROUTES.x.y, ...)"**

The suggestion resolves the exact route key from the generated `apiRoutes.meta.json` reverse-lookup
map and applies both the call rewrite and the `API_ROUTES` import in one action.

> **Tip:** If suggestions do not appear after updating the rule, restart the ESLint service:
> _Settings → Languages & Frameworks → JavaScript → Code Quality Tools → ESLint → ⋯ → Restart ESLint Service_

### VS Code

1. Place the caret on the underlined warning (or hover to see the lightbulb)
2. Press **Cmd+.** / **Ctrl+.** (Quick Fix)
3. Select **"Replace with cy.interceptApi(API\_ROUTES.x.y, ...)"** from the Quick Fix menu

The suggestion appears directly in the Quick Fix list alongside other code actions. No additional
configuration is required.

> **Tip:** If suggestions are missing after initial setup, run
> **"ESLint: Restart ESLint Server"** from the Command Palette.

### URL-only intercepts

For `cy.intercept('/api/v1/...')` calls without an explicit HTTP method, the IDE offers one
suggestion per matching method found in the registry (e.g. one entry for `GET`, another for `POST`
if both exist). Choose the one that matches the intended semantics.

---

## When to Still Use cy.intercept()

`cy.interceptApi()` covers static responses only. Use bare `cy.intercept()` with a callback handler
for any scenario that requires dynamic behaviour:

```typescript
// ✅ Keep as cy.intercept() — CRUD mock database
cy.intercept('GET', '/api/v1/management/bridges', (req) => {
  req.reply(200, { items: factory.bridge.getAll() })
})

cy.intercept('POST', '/api/v1/management/bridges', (req) => {
  factory.bridge.create(req.body)
  req.reply(200, req.body)
})

// ✅ Keep as cy.intercept() — non-API URL
cy.intercept('https://api.github.com/repos/hivemq/hivemq-edge/releases', {
  statusCode: 202,
  log: false,
})
```

These patterns are excluded from the ESLint rule and are the intended long-term use cases for raw
`cy.intercept()`.

---

## Related Documentation

**Cypress:**

- [Cypress Guide](../guides/CYPRESS_GUIDE.md) — selector strategy, custom commands, debugging
- [Testing Guide](../guides/TESTING_GUIDE.md) — E2E structure, Page Object pattern

**API & Mocking:**

- [MSW API Mocking](./MSW_MOCKING.md) — component and unit test mocking (Vitest / component Cypress)
- [OpenAPI Integration](./OPENAPI_INTEGRATION.md) — client generation workflow (`pnpm dev:openAPI`)

---

**See:** [API Documentation Index](./INDEX.md) · [Documentation Index](../INDEX.md)
